# file opened: NEMO-80.asm
  1   0000              ;=========================================================================================================================
  2   0000              ; Thiago Turcato do Rego - 2024
  3   0000              ; Project: NEMO-80, New Monitor for CEDM-80
  4   0000              ; File: NEMO-80.asm
  5   0000              ;=========================================================================================================================
  6   0000
  7   0000              ;========================================= TERMINOLOGIAS, CONVENÇÕES E ORGANIZAÇÃO =======================================
  8   0000              ;
  9   0000              ; -- CONVENÇÕES DE SÍMBOLOS --
 10   0000              ; - Símbolos em LETRAS MAIUSCULAS = constantes (podem ser constantes que indicam uma posição de memória)
 11   0000              ; - Labels que começam com "." são entradas locais dentro de uma rotina
 12   0000              ; - Labels que começam com "_" são subrotinas auxiliares locais (úteis apenas para outra subrotina)
 13   0000              ; - Labels que iniciam com "sys_" são subrotinas de sistema, que podem ser usadas pelo usuário (leitura de teclado etc.)
 14   0000              ; - Labels outros são do programa monitor e também podem ser chamados pelo usuário
 15   0000              ;
 16   0000              ;==========================================================================================================================
 17   0000
 18   0000              ; Diretivas de compilação para alocação de memória e geração de arquivo SLD para o simulador DeZog de CPU Z80 (VSCode)
 19   0000               DEVICE NOSLOT64K
 20   0000               SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
 21   0000
 22   0000              ;******** Definição de constantes ********
 23   0000              ; Endereço inicial da ROM e tamanho (2 KiB = 2048 bytes, 0000H ~ 07FFH)
 24   0000              ROMBEGIN        EQU 0000H
 25   0000              ROMSIZE         EQU 800H
 26   0000
 27   0000              ; Endereço inicial da RAM e tamanho (2 KiB = 2048 bytes, 2000H ~ 27FFH)
 28   0000              RAMBEGIN        EQU 2000H
 29   0000              RAMSIZE         EQU 800H
 30   0000
 31   0000              ; Constantes de codificação para exibição de caracteres no display do CEDM-80
 32   0000              CHR_0           EQU 0C0H
 33   0000              CHR_1           EQU 0F9H
 34   0000              CHR_2           EQU 0A4H
 35   0000              CHR_3           EQU 0B0H
 36   0000              CHR_4           EQU 099H
 37   0000              CHR_5           EQU 092H
 38   0000              CHR_6           EQU 082H
 39   0000              CHR_7           EQU 0F8H
 40   0000              CHR_8           EQU 080H
 41   0000              CHR_9           EQU 090H
 42   0000              CHR_A           EQU 088H
 43   0000              CHR_B           EQU 083H
 44   0000              CHR_C           EQU 0C6H
 45   0000              CHR_D           EQU 0A1H
 46   0000              CHR_E           EQU 086H
 47   0000              CHR_F           EQU 08EH
 48   0000              CHR_G           EQU 082H
 49   0000              CHR_H           EQU 089H
 50   0000              CHR_I           EQU 0F9H
 51   0000              CHR_J           EQU 0E1H
 52   0000              CHR_L           EQU 0C7H
 53   0000              CHR_M           EQU 0AAH
 54   0000              CHR_N           EQU 0C8H
 55   0000              CHR_O           EQU 0C0H
 56   0000              CHR_P           EQU 08CH
 57   0000              CHR_Q           EQU 098H
 58   0000              CHR_R           EQU 0AFH
 59   0000              CHR_S           EQU 092H
 60   0000              CHR_T           EQU 087H
 61   0000              CHR_U           EQU 0C1H
 62   0000              CHR_EQUAL       EQU 0B7H
 63   0000
 64   0000              ; Endereços de I/O (I/O ports)
 65   0000              DISP            EQU 01H
 66   0000              SEL_DISP        EQU 02H ;03H
 67   0000              KEYB            EQU 01H
 68   0000
 69   0000              ; Constantes indicativas de endereços de memória
 70   0000              ;
 71   0000              ; RESERVADO PARA SISTEMA: END. 2600H ~ 27FF
 72   0000
 73   0000              ; RAM para sistema até 27FF
 74   0000              RAM_SYS_START   EQU 2600H    ; Inicio da área de RAM reservada para sistema
 75   0000
 76   0000              RAM_DRAFT1      EQU 2768H    ; Área de rascunho para as subrotinas
 77   0000              RAM_DRAFT2      EQU 2769H    ; Área de rascunho para as subrotinas
 78   0000              RAM_DRAFT3      EQU 276AH    ; Área de rascunho para as subrotinas
 79   0000              RAM_DRAFT4      EQU 276BH    ; Área de rascunho para as subrotinas
 80   0000              RAM_DRAFT5      EQU 276CH    ; Área de rascunho para as subrotinas
 81   0000              RAM_KEYB_CONV   EQU 276DH    ; Código da tecla pressionada já decodificado de 00H a 17H (24 teclas)
 82   0000              RAM_KEYBOARD    EQU 276EH    ; Valor binário na matriz da tecla pressionada
 83   0000              RAM_KEYB_COL    EQU 276FH    ; Coluna selecionada na varredura do teclado
 84   0000              RAM_DISPLAY     EQU 2770H    ; Caracteres a serem exibidos no display pos. 2770H a 2775H
 85   0000
 86   0000              ; Stack (pilha de dados) = 2780H a 27FFH
 87   0000              RAM_STACK_0     EQU 2780H
 88   0000              RAM_STACK_127   EQU 27FFH
 89   0000
 90   0000              ; Variáveis do programa, do endereço 25FF para trás (128 bytes)
 91   0000              VAR_REG_A       EQU 25F0H
 92   0000              VAR_REG_B       EQU 25F1H
 93   0000              VAR_REG_C       EQU 25F2H
 94   0000              VAR_REG_D       EQU 25F3H
 95   0000              VAR_REG_E       EQU 25F4H
 96   0000              VAR_REG_F       EQU 25F5H
 97   0000              VAR_REG_H       EQU 25F6H
 98   0000              VAR_REG_L       EQU 25F7H
 99   0000              VAR_REG_I       EQU 25F8H
100   0000              VAR_REG_R       EQU 25F9H
101   0000              VAR_REG_SPL     EQU 25FAH
102   0000              VAR_REG_SPH     EQU 25FBH
103   0000              VAR_TEST        EQU 25FCH
104   0000              VAR_CURR_ADDRL  EQU 25FEH
105   0000              VAR_CURR_ADDRH  EQU 25FFH
106   0000
107   0000              ;******** Início do programa monitor ********
108   0000                  ORG ROMBEGIN
109   0000
110   0000              ; ********************** Programa principal **********************
111   0000              ; Ajustes e configuração iniciais
112   0000 31 FF 27         LD SP, 27FFH                ; Ajusta o stack pointer (pilha de dados) no fim da memória RAM. Considerado 128 bytes de stack 2780 até 27FF
113   0003
114   0003              ; Inicializações antes do programa
115   0003              initialization:
116   0003 CD 62 02         CALL sys_clean_ram_disp     ; Limpa a memória de exibição no display
117   0006
118   0006              ; Inicio do programa
119   0006              ini_program:
120   0006 3E C8            LD A,CHR_N                  ; Mensagem de inicialização NEMO-80
121   0008 32 70 27         LD (RAM_DISPLAY),A
122   000B 3E 86            LD A,CHR_E
123   000D 32 71 27         LD (RAM_DISPLAY+1),A
124   0010 3E AA            LD A,CHR_M
125   0012 32 72 27         LD (RAM_DISPLAY+2),A
126   0015 3E C0            LD A,CHR_O
127   0017 32 73 27         LD (RAM_DISPLAY+3),A
128   001A 3E 80            LD A,CHR_8
129   001C 32 74 27         LD (RAM_DISPLAY+4),A
130   001F 3E C0            LD A,CHR_0
131   0021 32 75 27         LD (RAM_DISPLAY+5),A
132   0024
133   0024              loop_main_menu:                 ; Rotina de menu inicial
134   0024 CD D0 03         CALL sys_keyb_disp
135   0027 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Lê memória de tecla pressionada
136   002A CB BF            RES 7,A                     ; Reseta o bit indicador de tecla pressionada
137   002C FE 10            CP 10H                      ; Se pressionada tecla ADR, chama entrada de endereço
138   002E CC F4 01         CALL Z, menu_addr
139   0031 FE 15            CP 15H
140   0033 CC 45 00         CALL Z, menu_reg
141   0036 18 EC            JR loop_main_menu
142   0038
143   0038 00 53 55 42      DB 0H,"SUBROUTINES",0H
143   003C 52 4F 55 54
143   0040 49 4E 45 53
143   0044 00
144   0045              ;
145   0045              ; ********************** Subroutinas **********************
146   0045              ;
147   0045
148   0045              ; Subrotina de edição/exibição dos valores dos registradores
149   0045              menu_reg:
150   0045 F5               PUSH AF                     ; Reserva AF na pilha para poder extrair o valor de F
151   0046 ED 73 FA 25      LD (VAR_REG_SPL),SP         ; Guarda o valor de todos os registradores em posições de memória
152   004A 32 F0 25         LD (VAR_REG_A),A
153   004D 78               LD A,B
154   004E 32 F1 25         LD (VAR_REG_B),A
155   0051 79               LD A,C
156   0052 32 F2 25         LD (VAR_REG_C),A
157   0055 7A               LD A,D
158   0056 32 F3 25         LD (VAR_REG_D),A
159   0059 7B               LD A,E
160   005A 32 F4 25         LD (VAR_REG_E),A
161   005D 7C               LD A,H
162   005E 32 F6 25         LD (VAR_REG_H),A
163   0061 7D               LD A,L
164   0062 32 F7 25         LD (VAR_REG_L),A
165   0065 ED 57            LD A,I
166   0067 32 F8 25         LD (VAR_REG_I),A
167   006A ED 5F            LD A,R
168   006C 32 F9 25         LD (VAR_REG_R),A
169   006F 2A FA 25         LD HL,(VAR_REG_SPL)         ; Extração do valor de F: ao empurrar AF para a pilha, o valor F fica na memória na posição de SP
170   0072 7E               LD A,(HL)                   ; Extrai o valor da posição na pilha
171   0073 32 F5 25         LD (VAR_REG_F),A            ; Guarda o valor de F na memória
172   0076 F1               POP AF
173   0077 CD BE 02         CALL sys_wait_keyrelease    ; Aguarda o usuário soltar o botão REG
174   007A CD 62 02         CALL sys_clean_ram_disp     ; Limpa a exibição no display
175   007D 3E 00            LD A,00H                    ; Zera a posição de memória DRAFT2, que será usada de rascunho
176   007F 32 69 27         LD (RAM_DRAFT2),A
177   0082              .menu_reg_a:
178   0082 3E B7            LD A,CHR_EQUAL              ; Coloca um caracter de "=" no DISPLAY+3
179   0084 32 73 27         LD (RAM_DISPLAY+3),A
180   0087 3A 69 27         LD A,(RAM_DRAFT2)           ; RAM_DRAFT2 contém qual o item atualmente exibido no menu dos registradores 00 = Reg. A ~ 0A = SP.
181   008A FE 00            CP 00H
182   008C 20 0B            JR NZ,.menu_reg_b           ; Se o item atual a exibir não for A, segue para testar se é B
183   008E 0E 88            LD C,CHR_A
184   0090 21 F0 25         LD HL,VAR_REG_A
185   0093 32 69 27         LD (RAM_DRAFT2),A
186   0096 C3 32 01         JP .menu_reg_dispin
187   0099              .menu_reg_b:
188   0099 FE 01            CP 01H
189   009B 20 0B            JR NZ,.menu_reg_c           ; Se o item atual a exibir não for B, segue para testar se é C
190   009D 0E 83            LD C,CHR_B
191   009F 21 F1 25         LD HL,VAR_REG_B
192   00A2 32 69 27         LD (RAM_DRAFT2),A
193   00A5 C3 32 01         JP .menu_reg_dispin
194   00A8              .menu_reg_c:
195   00A8 FE 02            CP 02H
196   00AA 20 0B            JR NZ,.menu_reg_d           ; Se o item atual a exibir não for C, segue para testar se é D
197   00AC 0E C6            LD C,CHR_C
198   00AE 21 F2 25         LD HL,VAR_REG_C
199   00B1 32 69 27         LD (RAM_DRAFT2),A
200   00B4 C3 32 01         JP .menu_reg_dispin
201   00B7              .menu_reg_d:
202   00B7 FE 03            CP 03H
203   00B9 20 0B            JR NZ,.menu_reg_e           ; Se o item atual a exibir não for D, segue para testar se é E
204   00BB 0E A1            LD C,CHR_D
205   00BD 21 F3 25         LD HL,VAR_REG_D
206   00C0 32 69 27         LD (RAM_DRAFT2),A
207   00C3 C3 32 01         JP .menu_reg_dispin
208   00C6              .menu_reg_e:
209   00C6 FE 04            CP 04H
210   00C8 20 0B            JR NZ,.menu_reg_f           ; Se o item atual a exibir não for E, segue para testar se é F
211   00CA 0E 86            LD C,CHR_E
212   00CC 21 F4 25         LD HL,VAR_REG_E
213   00CF 32 69 27         LD (RAM_DRAFT2),A
214   00D2 C3 32 01         JP .menu_reg_dispin
215   00D5              .menu_reg_f:
216   00D5 FE 05            CP 05H
217   00D7 20 0B            JR NZ,.menu_reg_h           ; Se o item atual a exibir não for F, segue para testar se é H
218   00D9 0E 8E            LD C,CHR_F
219   00DB 21 F5 25         LD HL,VAR_REG_F
220   00DE 32 69 27         LD (RAM_DRAFT2),A
221   00E1 C3 32 01         JP .menu_reg_dispin
222   00E4              .menu_reg_h:
223   00E4 FE 06            CP 06H
224   00E6 20 0B            JR NZ,.menu_reg_l           ; Se o item atual a exibir não for H, segue para testar se é L
225   00E8 0E 89            LD C,CHR_H
226   00EA 21 F6 25         LD HL,VAR_REG_H
227   00ED 32 69 27         LD (RAM_DRAFT2),A
228   00F0 C3 32 01         JP .menu_reg_dispin
229   00F3              .menu_reg_l:
230   00F3 FE 07            CP 07H
231   00F5 20 0B            JR NZ,.menu_reg_i           ; Se o item atual a exibir não for L, segue para testar se é I
232   00F7 0E C7            LD C,CHR_L
233   00F9 21 F7 25         LD HL,VAR_REG_L
234   00FC 32 69 27         LD (RAM_DRAFT2),A
235   00FF C3 32 01         JP .menu_reg_dispin
236   0102              .menu_reg_i:
237   0102 FE 08            CP 08H
238   0104 20 0B            JR NZ,.menu_reg_r           ; Se o item atual a exibir não for I, segue para testar se é R
239   0106 0E F9            LD C,CHR_I
240   0108 21 F8 25         LD HL,VAR_REG_I
241   010B 32 69 27         LD (RAM_DRAFT2),A
242   010E C3 32 01         JP .menu_reg_dispin
243   0111              .menu_reg_r:
244   0111 FE 09            CP 09H
245   0113 20 0B            JR NZ,.menu_reg_sp          ; Se o item atual a exibir não for R, segue para testar se é SP
246   0115 0E AF            LD C,CHR_R
247   0117 21 F9 25         LD HL,VAR_REG_R
248   011A 32 69 27         LD (RAM_DRAFT2),A
249   011D C3 32 01         JP .menu_reg_dispin
250   0120              .menu_reg_sp:
251   0120 FE 0A            CP 0AH
252   0122 C2 82 00         JP NZ,.menu_reg_a           ; Se o item atual a exibir não for SP, retorna para o inicio do menu, em Reg. A
253   0125 06 92            LD B,CHR_S
254   0127 0E 8C            LD C,CHR_P
255   0129 21 FA 25         LD HL,VAR_REG_SPL
256   012C 32 69 27         LD (RAM_DRAFT2),A
257   012F C3 A0 01         JP .menu_reg_dispin16
258   0132              .menu_reg_dispin:               ; Exibição ou alteração de registradores de 8 bits
259   0132 79               LD A,C
260   0133 32 72 27         LD (RAM_DISPLAY+2),A
261   0136 CD 72 02         CALL sys_disp_data
262   0139 3A 6D 27         LD A,(RAM_KEYB_CONV)
263   013C CB 7F            BIT 7,A
264   013E 28 F2            JR Z,.menu_reg_dispin
265   0140 CB BF            RES 7,A
266   0142              .menu_reg_numkey:               ; Pressionada tecla de valor numérico indicando alteração de valor do registrador
267   0142 FE 0F            CP 0FH
268   0144 38 02            JR C,.menu_reg_indata
269   0146 18 0C            JR .menu_reg_minus
270   0148              .menu_reg_indata:
271   0148 CD BE 02         CALL sys_wait_keyrelease
272   014B CD CA 02         CALL sys_in_data
273   014E 3A 69 27         LD A,(RAM_DRAFT2)
274   0151 C3 82 00         JP .menu_reg_a
275   0154              .menu_reg_minus:                ; Pressionada tecla "-" para navegação entre os registradores exibidos no display
276   0154 FE 12            CP 12H
277   0156 20 11            JR NZ,.menu_reg_plus
278   0158 3A 69 27         LD A,(RAM_DRAFT2)
279   015B FE 00            CP 00H
280   015D 28 04            JR Z,.menu_reg_nodec
281   015F 3D               DEC A
282   0160 32 69 27         LD (RAM_DRAFT2),A
283   0163              .menu_reg_nodec:
284   0163 CD BE 02         CALL sys_wait_keyrelease
285   0166 C3 82 00         JP .menu_reg_a
286   0169              .menu_reg_plus:                 ; Pressionada tecla "+" para navegação entre os registradores exibidos no display
287   0169 FE 13            CP 13H
288   016B 20 12            JR NZ,.menu_reg_otherkey
289   016D 3A 69 27         LD A,(RAM_DRAFT2)
290   0170 FE 0A            CP 0AH
291   0172 CA 79 01         JP Z,.menu_reg_noinc
292   0175 3C               INC A
293   0176 32 69 27         LD (RAM_DRAFT2),A
294   0179              .menu_reg_noinc:
295   0179 CD BE 02         CALL sys_wait_keyrelease
296   017C C3 82 00         JP .menu_reg_a
297   017F              .menu_reg_otherkey:             ; Ao finalizar a rotina dos registradores, transfere os valores manipulados na memória para registradore
298   017F 3A F1 25         LD A,(VAR_REG_B)
299   0182 47               LD B,A
300   0183 3A F2 25         LD A,(VAR_REG_C)
301   0186 4F               LD C,A
302   0187 3A F3 25         LD A,(VAR_REG_D)
303   018A 57               LD D,A
304   018B 3A F4 25         LD A,(VAR_REG_E)
305   018E 5F               LD E,A
306   018F 3A F6 25         LD A,(VAR_REG_H)
307   0192 67               LD H,A
308   0193 3A F7 25         LD A,(VAR_REG_L)
309   0196 6F               LD L,A
310   0197 3A F8 25         LD A,(VAR_REG_I)
311   019A ED 47            LD I,A
312   019C 3A F0 25         LD A,(VAR_REG_A)
313   019F C9               RET
314   01A0              .menu_reg_dispin16:             ; Exibição ou alteração de registradores de 16 bits
315   01A0 78               LD A,B
316   01A1 32 74 27         LD (RAM_DISPLAY+4),A
317   01A4 79               LD A,C
318   01A5 32 75 27         LD (RAM_DISPLAY+5),A
319   01A8 CD 81 02         CALL sys_disp_addr
320   01AB 3A 6D 27         LD A,(RAM_KEYB_CONV)
321   01AE CB 7F            BIT 7,A
322   01B0 28 EE            JR Z,.menu_reg_dispin16
323   01B2 CB BF            RES 7,A
324   01B4              .menu_reg_numkey16:
325   01B4 FE 0F            CP 0FH
326   01B6 38 02            JR C,.menu_reg_indata16
327   01B8 18 09            JR .menu_reg_minus16
328   01BA              .menu_reg_indata16:
329   01BA CD BE 02         CALL sys_wait_keyrelease
330   01BD 3A 69 27         LD A,(RAM_DRAFT2)
331   01C0 C3 82 00         JP .menu_reg_a
332   01C3              .menu_reg_minus16:
333   01C3 FE 12            CP 12H
334   01C5 20 14            JR NZ,.menu_reg_plus16
335   01C7 3A 69 27         LD A,(RAM_DRAFT2)
336   01CA FE 00            CP 00H
337   01CC 28 04            JR Z,.menu_reg_nodec16
338   01CE 3D               DEC A
339   01CF 32 69 27         LD (RAM_DRAFT2),A
340   01D2              .menu_reg_nodec16:
341   01D2 CD BE 02         CALL sys_wait_keyrelease
342   01D5 CD 62 02         CALL sys_clean_ram_disp
343   01D8 C3 82 00         JP .menu_reg_a
344   01DB              .menu_reg_plus16:
345   01DB FE 13            CP 13H
346   01DD 20 A0            JR NZ,.menu_reg_otherkey
347   01DF 3A 69 27         LD A,(RAM_DRAFT2)
348   01E2 FE 0A            CP 0AH
349   01E4 28 04            JR Z,.menu_reg_noinc16
350   01E6 3C               INC A
351   01E7 32 69 27         LD (RAM_DRAFT2),A
352   01EA              .menu_reg_noinc16:
353   01EA CD BE 02         CALL sys_wait_keyrelease
354   01ED CD 62 02         CALL sys_clean_ram_disp
355   01F0 C3 82 00         JP .menu_reg_a
356   01F3 00               DB 00H
357   01F4
358   01F4              ; Subrotina de edição/exibição da memória
359   01F4              menu_addr:
360   01F4 CD 62 02         CALL sys_clean_ram_disp     ; Limpa a memória do display
361   01F7 CD BE 02         CALL sys_wait_keyrelease    ; Aguarda a tecla ADR ser solta
362   01FA              menu_addr_in:
363   01FA 3E 00            LD A,00H                    ; Zera as variáveis de posição de memória a ser lida ou alterada
364   01FC 32 FE 25         LD (VAR_CURR_ADDRL),A
365   01FF 32 FF 25         LD (VAR_CURR_ADDRH),A
366   0202 21 FE 25         LD HL,VAR_CURR_ADDRL        ; Carrega como ponteiro, o endereço da variável da posição de memória a ler/alterar
367   0205 CD 1A 03         CALL sys_in_addr            ; Chama a rotina de entrada de valor do endereço
368   0208              menu_wait_keypress:
369   0208 CD B2 02         CALL sys_wait_keypress      ; Depois da entrada do endereço, aguarda tecla DAT para entrada de dados ser pressionada ou outra para sair
370   020B CB BF            RES 7,A                     ; Reseta o bit de tecla pressionada do reg. A
371   020D FE 11            CP 11H                      ; Se pressionada tecla DAT, vai para rotina de entrada de dado
372   020F 28 36            JR Z, menu_addr_data
373   0211 FE 12            CP 12H                      ; Se pressionada tecla "-", vai para rotina de decremento do endereço exibido
374   0213 28 02            JR Z, menu_addr_minus
375   0215 18 0F            JR menu_addr_isplus         ; Se a tecla pressionada não foi "-", verifica se foi pressionado "+"
376   0217              menu_addr_minus:                ; Rotina de decremento do endereço exibido
377   0217 2A FE 25         LD HL,(VAR_CURR_ADDRL)      ; Carrega o valor armazenado na variável do endereço exibido
378   021A 2B               DEC HL                      ; Decrementa o valor do endereço exibido usando HL
379   021B 22 FE 25         LD (VAR_CURR_ADDRL),HL      ; Escreve o valor decrementado na váriavel de endereço exibido
380   021E CD BE 02         CALL sys_wait_keyrelease    ; Aguarda o usuário soltar a tecla "-" pressionada
381   0221 21 FE 25         LD HL,VAR_CURR_ADDRL        ; Carrega como ponteiro, o endereço da variável da posição de memória a ler/alterar
382   0224 18 21            JR menu_addr_data           ; Vai para a rotina de entrada de dado dentro do endereço exibido
383   0226              menu_addr_isplus:
384   0226 FE 13            CP 13H                      ; Se pressionada tecla "+", vai para rotina de incremento do endereço exibido
385   0228 28 02            JR Z, menu_addr_plus
386   022A 18 0F            JR menu_addr_isgo           ; Se a tecla pressionada não foi "-", verifica se foi pressionado "GO"
387   022C              menu_addr_plus:                 ; Rotina de incremento do endereço obtido
388   022C 2A FE 25         LD HL,(VAR_CURR_ADDRL)      ; Carrega o valor armazenado na variável do endereço exibido
389   022F 23               INC HL                      ; Incrementa o valor do endereço exibido usando HL
390   0230 22 FE 25         LD (VAR_CURR_ADDRL),HL      ; Escreve o valor incrementado na váriavel de endereço exibido
391   0233 CD BE 02         CALL sys_wait_keyrelease    ; Aguarda o usuário soltar a tecla "+" pressionada
392   0236 21 FE 25         LD HL,VAR_CURR_ADDRL        ; Carrega como ponteiro, o endereço da variável da posição de memória a ler/alterar
393   0239 18 0C            JR menu_addr_data           ; Vai para a rotina de entrada de dado dentro do endereço exibido
394   023B              menu_addr_isgo:
395   023B FE 14            CP 14H                      ; Se pressionada tecla "GO", chama execução no endereço atual
396   023D 28 02            JR Z, menu_addr_go
397   023F 18 04            JR menu_addr_otherkey       ; Se a tecla pressionada não foi nenhuma das anteriores, sai do menu de endereço e volta para o menu inicial
398   0241              menu_addr_go:                   ; Rotina da tecla "GO" de execução do programa a partir do endereço exibido
399   0241 2A FE 25         LD HL,(VAR_CURR_ADDRL)      ; Carrega o endereço exibido em HL para execução
400   0244 E9               JP HL                       ; Salta a execução para o endereço exibido
401   0245              menu_addr_otherkey:
402   0245 18 17            JR menu_addr_end            ; Se outra tecla foi pressionada, que não seja "DAT", "+", "-" ou "GO", finaliza a entrada de endereço
403   0247              menu_addr_data:
404   0247 21 FE 25         LD HL,VAR_CURR_ADDRL        ; Carrega como ponteiro, o endereço da variável da posição de memória a ler/alterar
405   024A CD 81 02         CALL sys_disp_addr          ; Exibe o endereço/posição de memória carregado
406   024D 2A FE 25         LD HL,(VAR_CURR_ADDRL)      ; Carrega o endereço exibido para referenciar com o dado nele existente
407   0250 CD 72 02         CALL sys_disp_data          ; Exibe o dado contido no endereço exibido
408   0253 CD BE 02         CALL sys_wait_keyrelease    ; Aguarda o usuário soltar a tecla "DAT" pressionada
409   0256 CD B2 02         CALL sys_wait_keypress      ; Aguarda o usuário pressionar alguma tecla para iniciar o processo de entrada de novo dado ou sair do menu
410   0259 CD CA 02         CALL sys_in_data            ; Processa a entrada de dado para o endereço exibido
411   025C 18 AA            JR menu_wait_keypress       ; Quando finalizada a entrada, volta para o inicio do menu de endereço para testar próxima tecla pressionada
412   025E              menu_addr_end:
413   025E 3E FF            LD A,0FFH                   ; Carrega FFH em A, para escapar de próximas condições de tecla pressionada do menu principal
414   0260 C9               RET                         ; Volta para o menu principal
415   0261 00               DB 00H
416   0262
417   0262              ; Subrotina de limpeza da area de memoria para o display
418   0262              ;
419   0262              sys_clean_ram_disp:             ; Inicializa area de memoria do display
420   0262 E5               PUSH HL                     ; Reserva HL
421   0263 C5               PUSH BC                     ; Reserva BC
422   0264 21 70 27         LD HL,RAM_DISPLAY           ; Inicio da RAM para display
423   0267 06 06            LD B,06                     ; Preparar ponteiro para 6 endereços a partir do inicio da RAM para display
424   0269              .loop_clean_disp:               ; Inicializa area de memoria do display, com FFH (nenhum segmento aceso)
425   0269 36 FF            LD (HL),0FFH                ; Limpa a exibição no display escrevendo 0FFH na posição de memória
426   026B 23               INC HL                      ; Coloca o ponteiro na próxima posição de memória
427   026C 10 FB            DJNZ .loop_clean_disp       ; Decrementa o reg. B e, se não for zero, continua o loop de limpeza da memória
428   026E C1               POP BC                      ; Retoma valor reservado de BC
429   026F E1               POP HL                      ; Retoma valor reservado de HL
430   0270 C9               RET
431   0271 00               DB 00H
432   0272
433   0272              ; Subrotina de exibição de dados no campo de dados (sys_disp_data)
434   0272              ; HL (e HL+1) = posição de memória onde está o dado a ser exibido
435   0272              sys_disp_data:
436   0272 C5               PUSH BC                     ; Reserva o valor de BC (C é usado na subrotina _sys_mem_conv2nibbles)
437   0273 D5               PUSH DE                     ; Reserva o valor de DE
438   0274 11 75 27         LD DE,RAM_DISPLAY+5         ; Coloca o ponteiro DE no 4.o display da esq. para a direita
439   0277 CD 99 02         CALL _sys_mem_conv2nibbles  ; Chama função que converte os dois nibbles (LSB) do dado apontado por HL em caracteres para o display
440   027A D1               POP DE                      ; Retoma valor reservado de DE
441   027B C1               POP BC                      ; Retoma valor reservado de BC
442   027C CD D0 03         CALL sys_keyb_disp          ; Exibe no display o valor do endereço
443   027F C9               RET
444   0280 00               DB 00H
445   0281
446   0281              ; Subrotina de exibição de dados no campo de endereço (sys_disp_addr)
447   0281              ; HL (e HL+1) = posição de memória onde está o dado a ser exibido
448   0281              sys_disp_addr:
449   0281 E5               PUSH HL
450   0282 C5               PUSH BC                     ; Reserva o valor de BC (C é usado na subrotina _sys_mem_conv2nibbles)
451   0283 D5               PUSH DE                     ; Reserva o valor de DE
452   0284 11 73 27         LD DE,RAM_DISPLAY+3         ; Coloca o ponteiro DE no 4.o display da esq. para a direita
453   0287 CD 99 02         CALL _sys_mem_conv2nibbles  ; Chama função que converte os dois nibbles (LSB) do dado apontado por HL em caracteres para o display
454   028A 23               INC HL                      ; Coloca ponteiro HL na próxima posição da variável de dado
455   028B 11 71 27         LD DE,RAM_DISPLAY+1         ; Coloca o ponteiro DE no 2.o display da esq. para a direita
456   028E CD 99 02         CALL _sys_mem_conv2nibbles  ; Chama função que converte os dois nibbles (MSB) do dado apontado por HL em caracteres para o display
457   0291 D1               POP DE                      ; Retoma valor reservado de DE
458   0292 C1               POP BC                      ; Retoma valor reservado de BC
459   0293 CD D0 03         CALL sys_keyb_disp          ; Exibe no display o valor do endereço
460   0296 E1               POP HL
461   0297 C9               RET
462   0298 00               DB 00H
463   0299
464   0299              ; Subrotina auxiliar das subrotinas de exibição no display
465   0299              ; Converte 2 nibbles de uma posição de memória em 2 bytes para exibição no display
466   0299              ; HL - Posição de entrada do dado a ser separado em nibbles
467   0299              ; DE - Posição mais alta para escrita dos dados convertidos para display
468   0299              _sys_mem_conv2nibbles
469   0299 7E               LD A,(HL)                   ; Lê o valor contido na posição de memória apontada por HL
470   029A E6 0F            AND 0FH                     ; Filtra apenas a parte menos signicativa
471   029C CD 89 03         CALL sys_conv_hexdisp       ; Converte a parte filtrada de hexa para o código de exibição no display
472   029F 79               LD A,C                      ; O código de exibição é devolvido em C. Transfere-o para A.
473   02A0 12               LD (DE),A                   ; Carrega o valor convertido para o display na posição apontada por DE
474   02A1 1B               DEC DE
475   02A2 7E               LD A,(HL)
476   02A3 CB 3F            SRL A
477   02A5 CB 3F            SRL A
478   02A7 CB 3F            SRL A
479   02A9 CB 3F            SRL A
480   02AB CD 89 03         CALL sys_conv_hexdisp
481   02AE 79               LD A,C
482   02AF 12               LD (DE),A
483   02B0 C9               RET
484   02B1 00               DB 00H
485   02B2
486   02B2              ; Subrotina para aguardar em loop uma tecla ser pressionada
487   02B2              ; A : Código da tecla + bit de tecla pressionada
488   02B2              sys_wait_keypress
489   02B2 CD D0 03         CALL sys_keyb_disp          ; Exibe display e lê teclado
490   02B5 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Lê a memória de tecla lida
491   02B8 CB 7F            BIT 7,A                     ; Verifica se alguma tecla foi pressionada (digitação de um endereço, p. ex.)
492   02BA 28 F6            JR Z,sys_wait_keypress      ; Fica em loop até uma tecla ser pressionada
493   02BC C9               RET
494   02BD 00               DB 00H
495   02BE
496   02BE              ; Subrotina para aguardar em loop uma tecla ser solta
497   02BE              ; A : Código da tecla + bit de tecla pressionada
498   02BE              sys_wait_keyrelease
499   02BE CD D0 03         CALL sys_keyb_disp          ; Exibe display e lê teclado
500   02C1 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Lê a memória de tecla lida
501   02C4 CB 7F            BIT 7,A
502   02C6 C8               RET Z                       ; Verifica se alguma tecla foi pressionada (digitação de um endereço, p. ex.)
503   02C7 18 F5            JR sys_wait_keyrelease      ; Fica em loop até uma tecla ser pressionada
504   02C9 00               DB 00H
505   02CA
506   02CA              ; Subrotina de entrada de valor no campo de dados (sys_in_data)
507   02CA              ; O software fica preso nessa rotina até que uma tecla de 10 a 17 seja pressionada
508   02CA              ; HL: Definição da primeira área de memória para uso com a entrada de dados (2 dígitos)
509   02CA              ; Teclas de 0 a F = serão reproduzidas no display e atualizam o valor em (HL)
510   02CA              ; Teclas de 10 a 17 = encerram o loop da subrotina, tecla pressionada em RAM_KEYB_CONV
511   02CA              ;       If !(keypress.bit7) then RST keyprsmem.bit7
512   02CA              ;       If  (keypress.bit7) &&  (keyprsmem.bit7) then end
513   02CA              ;       If  (keypress.bit7) && !(keyprsmem.bit7) then SET keyprsmem.bit7 and process the input
514   02CA              sys_in_data:
515   02CA C5               PUSH BC                     ; Guarda na pilha valor atual de BC para poder usar BC na subrotina
516   02CB 3E FF            LD A,0FFH
517   02CD 32 74 27         LD (RAM_DISPLAY+4),A        ; Limpa memória de exibição do 5.o display de endereçamento
518   02D0 32 75 27         LD (RAM_DISPLAY+5),A        ; Limpa memória de exibição do 6.o display de endereçamento
519   02D3 3E 00            LD A,00H
520   02D5 32 68 27         LD (RAM_DRAFT1),A
521   02D8              .in_data_input_loop:
522   02D8 CD D0 03         CALL sys_keyb_disp          ; Chama atualização do display e teclado
523   02DB 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Recupera tecla atualmente pressionada (keypress = RAM_KEYB_CONV)
524   02DE CB 7F            BIT 7,A                     ; Testa bit 7 de RAM_KEYB_CONV para verificar se alguma tecla está pressionada (keypress.bit7)
525   02E0 28 2B            JR Z,.in_data_rst_keyprsmem ; Bit 7 keypress é zero (tecla solta): reseta bit 7 memória (keypressmem)
526   02E2 3A 68 27         LD A,(RAM_DRAFT1)           ; Recupera memória de tecla pressionada (keyprsmem)
527   02E5 CB 7F            BIT 7,A                     ; Testa bit 7, sinalizador de tecla pressionada anteriormente (keyprsmem.bit7)
528   02E7 20 EF            JR NZ,.in_data_input_loop   ; bit 7 memória não zero (setado): não faz nada, finaliza a subrotina
529   02E9 CB FF            SET 7,A                     ; Seta bit 7 e segue com o processamento da tecla pressionada
530   02EB 32 68 27         LD (RAM_DRAFT1),A           ; Salva na memória de tecla pressionada (keyprsmem), que há uma tecla pressionada (bit 7 setado)
531   02EE 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Recupera tecla atualmente pressionada (keypress = RAM_KEYB_CONV)
532   02F1 CB BF            RES 7,A                     ; Reseta o bit 7 no registrador A para testar se a tecla é numérica ou de função
533   02F3 FE 10            CP 10H                      ; Compara o código da tecla com 10H (16)
534   02F5 38 02            JR C,.in_data_num_key       ; Se for menor que 16, a tecla é numérica, segue para o processamento da entrada numérica
535   02F7 18 1E            JR .in_data_end             ; Se for maior ou igual a 16, a tecla é de função, encerra o loop de entrada numérica
536   02F9              .in_data_num_key:
537   02F9 CD 89 03         CALL sys_conv_hexdisp       ; Converte o código da tecla hex (= A) em código de exibição correspondente no display -> C
538   02FC CD B6 03         CALL sys_sftl_data_disp     ; Desloca no display 1 dígito para esquerda e acrescenta novo dígito contido em C
539   02FF                                              ; Atualização do valor na variável apontada por HL, suponha dado 8 bits = "XY"
540   02FF 4F               LD C,A                      ; Guarda o valor digitado em C para poder usar o A, suponha valor digitado = "0K"
541   0300 7E               LD A,(HL)                   ; Lê o dado da parte menos significativa -> A = "XY"
542   0301 CB 27            SLA A                       ; Desloca parte menos significativa para esquerda -> A = "Y0"
543   0303 CB 27            SLA A
544   0305 CB 27            SLA A
545   0307 CB 27            SLA A
546   0309 B1               OR C                        ; Combina valor digitado com valor deslocado -> "Y0" OR "0K" = "YK"
547   030A 77               LD (HL),A                   ; Guarda valor combinado na parte menos significativa. Resultado final = "YK"
548   030B 18 CB            JR .in_data_input_loop      ; Retorna ao inicio da subrotina de entrada para testar se há próximo digito de entrada
549   030D              .in_data_rst_keyprsmem:
550   030D 3A 68 27         LD A,(RAM_DRAFT1)           ; HL contém a posição de memória da variável de sistema
551   0310 CB BF            RES 7,A                     ; Reseta o bit 7, sinalizador de tecla pressionada anteriormente
552   0312 32 68 27         LD (RAM_DRAFT1),A           ; Grava de volta na memória de sinalização de tecla pressionada anteriormente
553   0315 18 C1            JR .in_data_input_loop      ; Retorna ao inicio da subrotina de entrada para testar se há próximo digito de entrada
554   0317              .in_data_end:
555   0317 C1               POP BC                      ; Recupera registrador BC
556   0318 C9               RET
557   0319 00               DB 00H
558   031A
559   031A              ; Subrotina de entrada de valor no campo de endereço (sys_in_addr)
560   031A              ; O software fica preso nessa rotina até que uma tecla de 10 a 17 seja pressionada
561   031A              ; HL: Definição da primeira área de memória para uso com a entrada de dados
562   031A              ;    (4 dígitos, sequencia little endian)
563   031A              ; Teclas de 0 a F = serão reproduzidas no display e atualizam o valor em (HL)
564   031A              ; Teclas de 10 a 17 = encerram o loop da subrotina, tecla pressionada em RAM_KEYB_CONV
565   031A              ;       If !(keypress.bit7) then RST keyprsmem.bit7
566   031A              ;       If  (keypress.bit7) &&  (keyprsmem.bit7) then end
567   031A              ;       If  (keypress.bit7) && !(keyprsmem.bit7) then SET keyprsmem.bit7 and process the input
568   031A              sys_in_addr:
569   031A C5               PUSH BC                     ; Guarda na pilha valor atual de BC para poder usar BC na subrotina
570   031B 3E FF            LD A,0FFH
571   031D 32 70 27         LD (RAM_DISPLAY),A          ; Limpa memória de exibição do 1.o display de endereçamento
572   0320 32 71 27         LD (RAM_DISPLAY+1),A        ; Limpa memória de exibição do 2.o display de endereçamento
573   0323 32 72 27         LD (RAM_DISPLAY+2),A        ; Limpa memória de exibição do 3.o display de endereçamento
574   0326 32 73 27         LD (RAM_DISPLAY+3),A        ; Limpa memória de exibição do 4.o display de endereçamento
575   0329              ;    CALL sys_clean_ram_disp     ; Limpa a memória de exibição no display
576   0329 3E 00            LD A,00H
577   032B 32 68 27         LD (RAM_DRAFT1),A
578   032E              .in_addr_input_loop:
579   032E CD D0 03         CALL sys_keyb_disp          ; Chama atualização do display e teclado
580   0331 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Recupera tecla atualmente pressionada (keypress = RAM_KEYB_CONV)
581   0334 CB 7F            BIT 7,A                     ; Testa bit 7 de RAM_KEYB_CONV para verificar se alguma tecla está pressionada (keypress.bit7)
582   0336 28 44            JR Z,.in_addr_rst_keyprsmem ; Bit 7 keypress é zero (tecla solta): reseta bit 7 memória (keypressmem)
583   0338 3A 68 27         LD A,(RAM_DRAFT1)           ; Recupera memória de tecla pressionada (keyprsmem)
584   033B CB 7F            BIT 7,A                     ; Testa bit 7, sinalizador de tecla pressionada anteriormente (keyprsmem.bit7)
585   033D 20 EF            JR NZ,.in_addr_input_loop   ; bit 7 memória não zero (setado): não faz nada, finaliza a subrotina
586   033F CB FF            SET 7,A                     ; Seta bit 7 e segue com o processamento da tecla pressionada
587   0341 32 68 27         LD (RAM_DRAFT1),A           ; Salva na memória de tecla pressionada (keyprsmem), que há uma tecla pressionada (bit 7 setado)
588   0344 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Recupera tecla atualmente pressionada (keypress = RAM_KEYB_CONV)
589   0347 CB BF            RES 7,A                     ; Reseta o bit 7 no registrador A para testar se a tecla é numérica ou de função
590   0349 FE 10            CP 10H                      ; Compara o código da tecla com 10H (16)
591   034B 38 02            JR C,.in_addr_num_key       ; Se for menor que 16, a tecla é numérica, segue para o processamento da entrada numérica
592   034D 18 37            JR .in_addr_end             ; Se for maior ou igual a 16, a tecla é de função, encerra o loop de entrada numérica
593   034F              .in_addr_num_key:
594   034F CD 89 03         CALL sys_conv_hexdisp       ; Converte o código da tecla hex (= A) em código de exibição correspondente no display -> C
595   0352 CD 9C 03         CALL sys_sftl_addr_disp    ; Desloca no display 1 dígito para esquerda e acrescenta novo dígito contido em C
596   0355                                              ; Atualização do valor na variável apontada por HL, suponha dado 16 bits = "WX YZ"
597   0355 4F               LD C,A                      ; Guarda o valor digitado em C para poder usar o A, suponha valor digitado = "0K"
598   0356 23               INC HL                      ; Vai para a parte mais significativa dos 16 bits
599   0357 7E               LD A,(HL)                   ; Lê o dado da parte mais significativa -> "WX"
600   0358 CB 27            SLA A                       ; Desloca parte mais significativa para esquerda -> "X0"
601   035A CB 27            SLA A
602   035C CB 27            SLA A
603   035E CB 27            SLA A
604   0360 47               LD B,A                      ; Guarda valor deslocado em B -> B = "X0"
605   0361 2B               DEC HL                      ; Coloca ponteiro na parte menos significativa
606   0362 7E               LD A,(HL)                   ; Lê o dado da parte menos significativa -> A = "YZ"
607   0363 CB 3F            SRL A                       ; Desloca parte menos significativa para direita -> A = "0Y"
608   0365 CB 3F            SRL A
609   0367 CB 3F            SRL A
610   0369 CB 3F            SRL A
611   036B B0               OR B                        ; Combina partes deslocadas A e B -> "X0" OR "0Y" = "XY"
612   036C 23               INC HL                      ; Coloca ponteiro na parte mais significativa
613   036D 77               LD (HL),A                   ; Guarda valor combinado na parte mais significativa -> (HL) = "XY"
614   036E 2B               DEC HL                      ; Coloca ponteiro na parte menos significativa
615   036F 7E               LD A,(HL)                   ; Lê o dado da parte menos significativa -> A = "YZ"
616   0370 CB 27            SLA A                       ; Desloca parte menos significativa para esquerda -> A = "Z0"
617   0372 CB 27            SLA A
618   0374 CB 27            SLA A
619   0376 CB 27            SLA A
620   0378 B1               OR C                        ; Combina valor digitado com valor deslocado -> "Z0" OR "0K" = "ZK"
621   0379 77               LD (HL),A                   ; Guarda valor combinado na parte menos significativa. Resultado final = "XYZK"
622   037A 18 B2            JR .in_addr_input_loop      ; Retorna ao inicio da subrotina de entrada para testar se há próximo digito de entrada
623   037C              .in_addr_rst_keyprsmem:
624   037C 3A 68 27         LD A,(RAM_DRAFT1)           ; HL contém a posição de memória da variável de sistema
625   037F CB BF            RES 7,A                     ; Reseta o bit 7, sinalizador de tecla pressionada anteriormente
626   0381 32 68 27         LD (RAM_DRAFT1),A           ; Grava de volta na memória de sinalização de tecla pressionada anteriormente
627   0384 18 A8            JR .in_addr_input_loop      ; Retorna ao inicio da subrotina de entrada para testar se há próximo digito de entrada
628   0386              .in_addr_end:
629   0386 C1               POP BC                      ; Recupera registrador BC
630   0387 C9               RET
631   0388 00               DB 00H
632   0389
633   0389              ; Subrotina que converte um digito hexadecimal para exibição no display (_conv_hexdisp)
634   0389              ; A = num. hexadecimal 1 dígito
635   0389              ; C = retorna o valor para exibição no display
636   0389              sys_conv_hexdisp:
637   0389 F5               PUSH AF
638   038A C5               PUSH BC
639   038B E5               PUSH HL
640   038C E6 0F            AND 0FH                     ; Isola o nibble menos significativo do código da tecla
641   038E 4F               LD C,A
642   038F 06 00            LD B,00H
643   0391 21 84 04         LD HL,DB_NUMCHAR
644   0394 09               ADD HL,BC
645   0395 7E               LD A,(HL)
646   0396 E1               POP HL
647   0397 C1               POP BC
648   0398 4F               LD C,A
649   0399 F1               POP AF
650   039A C9               RET
651   039B 00               DB 00H
652   039C
653   039C              ; Sub-subrotina de deslocamento da memória do display de endereço (RAM_DISPLAY) em 1 dígito para esquerda
654   039C              ; C = valor a ser inserido
655   039C              sys_sftl_addr_disp:
656   039C E5               PUSH HL
657   039D D5               PUSH DE
658   039E C5               PUSH BC
659   039F 21 70 27         LD HL,RAM_DISPLAY
660   03A2 54               LD D,H
661   03A3 5D               LD E,L
662   03A4 23               INC HL
663   03A5 0E 03            LD C,03
664   03A7 06 00            LD B,00
665   03A9 ED B0            LDIR
666   03AB 13               INC DE
667   03AC C1               POP BC
668   03AD F5               PUSH AF
669   03AE 2B               DEC HL
670   03AF 79               LD A,C
671   03B0 77               LD (HL),A
672   03B1 F1               POP AF
673   03B2 D1               POP DE
674   03B3 E1               POP HL
675   03B4 C9               RET
676   03B5 00               DB 00H
677   03B6
678   03B6              ; Sub-subrotina de deslocamento da memória do display de dados (RAM_DISPLAY+4) em 1 dígito para esquerda
679   03B6              ; C = valor a ser inserido
680   03B6              sys_sftl_data_disp:
681   03B6 E5               PUSH HL
682   03B7 D5               PUSH DE
683   03B8 C5               PUSH BC
684   03B9 21 74 27         LD HL,RAM_DISPLAY+4
685   03BC 54               LD D,H
686   03BD 5D               LD E,L
687   03BE 23               INC HL
688   03BF 0E 01            LD C,01
689   03C1 06 00            LD B,00
690   03C3 ED B0            LDIR
691   03C5 13               INC DE
692   03C6 C1               POP BC
693   03C7 F5               PUSH AF
694   03C8 2B               DEC HL
695   03C9 79               LD A,C
696   03CA 77               LD (HL),A
697   03CB F1               POP AF
698   03CC D1               POP DE
699   03CD E1               POP HL
700   03CE C9               RET
701   03CF 00               DB 00H
702   03D0
703   03D0              ; Subrotina de atualização do display/teclado (sys_keyb_disp)
704   03D0              ; Dados relevantes
705   03D0              ; (RAM_DISPLAY) = Inicio da sequencia das 6 posições de memória lidas pelo sistema para exibição no display
706   03D0              ;                 Dado gravado nas posições de memória são o estado de cada segmento do display
707   03D0              ; (RAM_KEYB_CONV) = Posição de memória onde é armazenado o código da tecla apertada e se há uma tecla apertada
708   03D0              ;                   Bits (1 byte):  P X X X K K K K
709   03D0              ;                   P: Se 1, alguma tecla pressionada; Se 0, nenhuma tecla pressionada
710   03D0              ;                   X: "Don't care" (sem função)
711   03D0              ;                   KKKK: 1 nibble do código de tecla cf. abaixo:
712   03D0              ;                   0 a 9H: Teclas "0" a "9" pressionadas (com o bit P)
713   03D0              ;                   A a FH: Teclas "A" a "F" pressionadas (com o bit P)
714   03D0              ;                   10H: Tecla "ADR"
715   03D0              ;                   11H: Tecla "DAT"
716   03D0              ;                   12H: Tecla "-"
717   03D0              ;                   13H: Tecla "+"
718   03D0              ;                   14H: Tecla "GO"
719   03D0              ;                   15H: Tecla "REG"
720   03D0              ;                   16H: Tecla "IV"
721   03D0              ;                   17H: Tecla Vazia
722   03D0              sys_keyb_disp:
723   03D0 C5               PUSH BC
724   03D1 E5               PUSH HL
725   03D2 3E 00            LD A,00
726   03D4 32 6D 27         LD (RAM_KEYB_CONV),A        ; Limpa variável de memória do teclado antes de ler o teclado
727   03D7 3E 01            LD A,01H                    ; Ajusta A para apontar para a primeira coluna de displays (mais significativa)
728   03D9 21 70 27         LD HL,RAM_DISPLAY           ; Carrega no ponteiro HL primeiro endereço da RAM de sistema para o display
729   03DC              .keyb_disp_loop:
730   03DC D3 02            OUT (SEL_DISP),A            ; Seleciona display apontado por A
731   03DE 4F               LD C,A                      ; Guarda o valor de A
732   03DF 3E FF            LD A,0FFH
733   03E1 D3 01            OUT (DISP),A
734   03E3                  ;LD B, 1
735   03E3                  ;CALL sys_delay_ms
736   03E3 DB 01            IN A,(KEYB)                 ; Lê o teclado na coluna atual
737   03E5 FE 00            CP 00
738   03E7 28 7B            JR Z,.wr_display            ; Se nada foi lido do teclado (nenhuma tecla apertada), vai para a atualização do display direto
739   03E9 32 6E 27         LD (RAM_KEYBOARD),A         ; Se algo foi lido do teclado, registra tecla para a coluna atual
740   03EC 79               LD A,C                      ; Recupera dado de qual coluna está sendo atualizada
741   03ED 32 6F 27         LD (RAM_KEYB_COL),A         ; Registra na memória de qual coluna é a tecla apertada
742   03F0              .keyb_disp_cnv:
743   03F0 3A 6E 27         LD A,(RAM_KEYBOARD)         ; Converte posição da tecla no valor correspondente que representa (função da tecla)
744   03F3 FE 01            CP 01                       ; Não foi considerada ainda a coluna nesse ponto
745   03F5 CA 1D 04         JP Z,.keyb_disp_num_0
746   03F8 FE 02            CP 02
747   03FA CA 22 04         JP Z,.keyb_disp_num_1
748   03FD FE 04            CP 04
749   03FF CA 27 04         JP Z,.keyb_disp_num_2
750   0402 FE 08            CP 08
751   0404 CA 2C 04         JP Z,.keyb_disp_num_3
752   0407 FE 10            CP 16
753   0409 CA 31 04         JP Z,.keyb_disp_num_4
754   040C FE 20            CP 32
755   040E CA 36 04         JP Z,.keyb_disp_num_5
756   0411 FE 40            CP 64
757   0413 CA 3B 04         JP Z,.keyb_disp_num_6
758   0416 FE 80            CP 128
759   0418 CA 40 04         JP Z,.keyb_disp_num_7
760   041B 18 47            JR .wr_display
761   041D              .keyb_disp_num_0:
762   041D 3E 00            LD A,00H
763   041F 47               LD B,A
764   0420 18 21            JR .keyb_col
765   0422              .keyb_disp_num_1:
766   0422 3E 01            LD A,01H
767   0424 47               LD B,A
768   0425 18 1C            JR .keyb_col
769   0427              .keyb_disp_num_2:
770   0427 3E 02            LD A,02H
771   0429 47               LD B,A
772   042A 18 17            JR .keyb_col
773   042C              .keyb_disp_num_3:
774   042C 3E 03            LD A,03H
775   042E 47               LD B,A
776   042F 18 12            JR .keyb_col
777   0431              .keyb_disp_num_4:
778   0431 3E 04            LD A,04H
779   0433 47               LD B,A
780   0434 18 0D            JR .keyb_col
781   0436              .keyb_disp_num_5:
782   0436 3E 05            LD A,05H
783   0438 47               LD B,A
784   0439 18 08            JR .keyb_col
785   043B              .keyb_disp_num_6:
786   043B 3E 06            LD A,06H
787   043D 47               LD B,A
788   043E 18 03            JR .keyb_col
789   0440              .keyb_disp_num_7:
790   0440 3E 07            LD A,07H
791   0442 47               LD B,A
792   0443              .keyb_col:
793   0443 3A 6F 27         LD A,(RAM_KEYB_COL)         ; Decodifica a coluna e calcula o código correto da tecla (0~7H: coluna 1, 8~FH: coluna 2; 10~17H: coluna 3)
794   0446 FE 01            CP 01
795   0448 28 0A            JR Z,.keyb_cnv_plus0
796   044A FE 02            CP 02
797   044C 28 09            JR Z,.keyb_cnv_plus8
798   044E FE 04            CP 04
799   0450 28 0A            JR Z,.keyb_cnv_plus16
800   0452 18 10            JR .wr_display
801   0454              .keyb_cnv_plus0:                ; Identificado como tecla da coluna 1 (0~7H)
802   0454 78               LD A,B
803   0455 18 08            JR .keyb_cnv_end
804   0457              .keyb_cnv_plus8:                ; Identificado como tecla da coluna 2 (8~FH)
805   0457 78               LD A,B
806   0458 C6 08            ADD A,08
807   045A 18 03            JR .keyb_cnv_end
808   045C              .keyb_cnv_plus16:               ; Identificado como tecla da coluna 1 (10~17H)
809   045C 78               LD A,B
810   045D C6 10            ADD A,16
811   045F              .keyb_cnv_end:
812   045F CB FF            SET 7,A                     ; Seta o bit 7 do valor convertido para dizer que a tecla foi lida, especialmente no caso do zero (0H)
813   0461 32 6D 27         LD (RAM_KEYB_CONV),A
814   0464              .wr_display:
815   0464 7E               LD A,(HL)
816   0465 D3 01            OUT (DISP),A
817   0467 06 02            LD B, 2
818   0469 CD 78 04         CALL sys_delay_ms
819   046C 23               INC HL
820   046D 79               LD A,C
821   046E 87               ADD A,A
822   046F FE 40            CP 64
823   0471 C2 DC 03         JP NZ, .keyb_disp_loop      ; Se não chegou na última coluna de atualização do display (64), vai para o próximo loop
824   0474 E1               POP HL
825   0475 C1               POP BC
826   0476 C9               RET
827   0477 00               DB 00H
828   0478
829   0478              ; Delay (operative, ms) for clk = 2 MHz (sys_delay_ms);
830   0478              ; Input: B = delay time (ms) 0,5% ;
831   0478              ; Affects registers A, B, F
832   0478              sys_delay_ms:
833   0478 F5               PUSH AF
834   0479              .delay_mult:
835   0479 78               LD A, B
836   047A 06 98            LD B, 152                ;Number of loops adjusted to A = delay ms with minimum error
837   047C              .delay_1ms:
838   047C 10 FE            DJNZ .delay_1ms
839   047E 47               LD B, A
840   047F 10 F8            DJNZ .delay_mult
841   0481 F1               POP AF
842   0482 C9               RET
843   0483 00               DB 00H
844   0484
845   0484              ; Código dos caracteres para exibição no display em sequencia de endereços para facilitar a conversão numérica
846   0484              DB_NUMCHAR EQU $
847   0484 C0               DB      0C0H                ; Caractere 0
848   0485 F9               DB      0F9H                ; Caractere 1
849   0486 A4               DB      0A4H                ; Caractere 2
850   0487 B0               DB      0B0H                ; Caractere 3
851   0488 99               DB      099H                ; Caractere 4
852   0489 92               DB      092H                ; Caractere 5
853   048A 82               DB      082H                ; Caractere 6
854   048B F8               DB      0F8H                ; Caractere 7
855   048C 80               DB      080H                ; Caractere 8
856   048D 90               DB      090H                ; Caractere 9
857   048E 88               DB      088H                ; Caractere A
858   048F 83               DB      083H                ; Caractere B
859   0490 C6               DB      0C6H                ; Caractere C
860   0491 A1               DB      0A1H                ; Caractere D
861   0492 86               DB      086H                ; Caractere E
862   0493 8E               DB      08EH                ; Caractere F
863   0494 FF               DB      0FFH                ; Tecla especial 1
864   0495 FF               DB      0FFH                ; Tecla especial 2
865   0496 FF               DB      0FFH                ; Tecla especial 3
866   0497 FF               DB      0FFH                ; Tecla especial 4
867   0498 FF               DB      0FFH                ; Tecla especial 5
868   0499 FF               DB      0FFH                ; Tecla especial 6
869   049A FF               DB      0FFH                ; Tecla especial 7
870   049B FF               DB      0FFH                ; Tecla especial 8
871   049C
872   049C              test_prog:
873   049C 3E 00            LD A,00H
874   049E 32 FC 25         LD (VAR_TEST),A
875   04A1 CD 62 02         CALL sys_clean_ram_disp
876   04A4 CD D0 03         CALL sys_keyb_disp
877   04A7              loop_test_inc:
878   04A7 3A FC 25         LD A,(VAR_TEST)
879   04AA 3C               INC A
880   04AB 32 FC 25         LD (VAR_TEST),A
881   04AE 21 FC 25         LD HL,VAR_TEST
882   04B1 06 14            LD B,20
883   04B3              loop_test_disp:
884   04B3 CD 72 02         CALL sys_disp_data
885   04B6 10 FB            DJNZ loop_test_disp
886   04B8 18 ED            JR loop_test_inc
887   04BA 76               HALT
888   04BB 00               DB 00H
# file closed: NEMO-80.asm
