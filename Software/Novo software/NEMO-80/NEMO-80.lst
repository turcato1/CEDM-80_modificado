# file opened: NEMO-80.asm
  1   0000              ;===========================================================================
  2   0000              ; Thiago Turcato do Rego - 2023
  3   0000              ; Project: NEMO-80, New Monitor for CEDM-80
  4   0000              ; File: NEMO-80.asm
  5   0000              ;===========================================================================
  6   0000
  7   0000              ;============ TERMINOLOGY, CONVENTIONS AND ORGANIZATION ====================
  8   0000              ; -- TERMINOLOGIES --
  9   0000              ; subr.  = subroutines
 10   0000              ; drcly = directly
 11   0000              ; aux. = auxiliary
 12   0000              ;
 13   0000              ; -- SYMBOLS CONVENTIONS --
 14   0000              ; - Symbols in UPPER CASE LETTERS = constants
 15   0000              ; - Labels starting with "." are local jump entry points
 16   0000              ; - Labels starting with "_" are local subroutines (aux. subr.)
 17   0000              ; - Labels starting with lower case letters (except for the cases below)
 18   0000              ;    are general function calls, open to any user
 19   0000              ; - Labels starting with "dmsg_" are ascii text formated messages to use
 20   0000              ;    for display (user interface messages)
 21   0000              ;
 22   0000              ;=============================================================================
 23   0000
 24   0000              ; Compilation directives for allocating memory (no bank) and SLD file generation
 25   0000               DEVICE NOSLOT64K
 26   0000               SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
 27   0000
 28   0000              ;******** Constants definition ********
 29   0000              ; ROM first address and size (2 KiB = 2048 bytes, 0000H ~ 07FFH)
 30   0000              ROMBEGIN        EQU 0000H
 31   0000              ROMSIZE         EQU 800H
 32   0000
 33   0000              ; RAM first address and size (2 KiB = 2048 bytes, 2000H ~ 27FFH)
 34   0000              RAMBEGIN        EQU 2000H
 35   0000              RAMSIZE         EQU 800H
 36   0000
 37   0000              ; Constants
 38   0000              CHR_0           EQU 0C0H
 39   0000              CHR_1           EQU 0F9H
 40   0000              CHR_2           EQU 0A4H
 41   0000              CHR_3           EQU 0B0H
 42   0000              CHR_4           EQU 099H
 43   0000              CHR_5           EQU 092H
 44   0000              CHR_6           EQU 082H
 45   0000              CHR_7           EQU 0F8H
 46   0000              CHR_8           EQU 080H
 47   0000              CHR_9           EQU 090H
 48   0000              CHR_A           EQU 088H
 49   0000              CHR_B           EQU 083H
 50   0000              CHR_C           EQU 0C6H
 51   0000              CHR_D           EQU 0A1H
 52   0000              CHR_E           EQU 086H
 53   0000              CHR_F           EQU 08EH
 54   0000
 55   0000
 56   0000              ; I/O addresses
 57   0000              DISP            EQU 01H
 58   0000              SEL_DISP        EQU 03H
 59   0000              KEYB            EQU 01H
 60   0000
 61   0000              ; RESERVADO PARA SISTEMA: END. 2600H ~ 27FF
 62   0000
 63   0000              ; RAM para sistema até 27FF
 64   0000              RAM_SYS_START   EQU 2600H    ; Inicio da área de RAM reservada para sistema
 65   0000
 66   0000              RAM_DRAFT1      EQU 2766H    ; Área de rascunho para as subrotinas
 67   0000              RAM_DRAFT2      EQU 2767H    ; Área de rascunho para as subrotinas
 68   0000              RAM_DRAFT3      EQU 2768H    ; Área de rascunho para as subrotinas
 69   0000              RAM_DRAFT4      EQU 2769H    ; Área de rascunho para as subrotinas
 70   0000              RAM_DRAFT5      EQU 276AH    ; Área de rascunho para as subrotinas
 71   0000              RAM_DRAFT6      EQU 276BH    ; Área de rascunho para as subrotinas
 72   0000              RAM_DRAFT7      EQU 276CH    ; Área de rascunho para as subrotinas
 73   0000              RAM_KEYB_CONV   EQU 276DH    ; Código da tecla pressionada já decodificado de 00 a 17 (24 teclas)
 74   0000              RAM_KEYBOARD    EQU 276EH    ; Valor binário na matriz da tecla pressionada
 75   0000              RAM_KEYB_COL    EQU 276FH    ; Coluna selecionada na varredura do teclado
 76   0000              RAM_DISPLAY     EQU 2770H    ; Caracteres a serem exibidos no display pos. 2770H a 2775H
 77   0000
 78   0000              ; Stack = 2780H a 27FFH
 79   0000              RAM_STACK_0     EQU 2780H
 80   0000              RAM_STACK_127   EQU 27FFH
 81   0000
 82   0000              ; Variáveis do programa, do endereço 25FF para trás (128 bytes)
 83   0000              VAR_VALUE_INS   EQU 25FEH
 84   0000              VAR_VALUE_IN    EQU 25FFH
 85   0000
 86   0000
 87   0000              ;******** Beggining of monitor program ********
 88   0000                  ORG ROMBEGIN
 89   0000
 90   0000              ; ********************** Programa principal **********************
 91   0000              ; Ajustes e configuração iniciais
 92   0000 31 FF 27         LD SP, 27FFH                ; Ajusta o stack pointer no fim da memória RAM. Considerado 128 bytes de stack 2780 até 27FF
 93   0003
 94   0003              ; Inicializações antes do programa
 95   0003              initialization:
 96   0003 CD 41 00         CALL sys_clean_ram_disp     ; Limpa a memória de exibição no display
 97   0006 3E 00            LD A,00H
 98   0008 32 FF 25         LD (VAR_VALUE_IN),A
 99   000B 32 FE 25         LD (VAR_VALUE_INS),A
100   000E
101   000E                  ; LD A,CHR_1
102   000E                  ; LD (RAM_DISPLAY),A
103   000E                  ; LD A,CHR_2
104   000E                  ; LD (RAM_DISPLAY+1),A
105   000E                  ; LD A,CHR_3
106   000E                  ; LD (RAM_DISPLAY+2),A
107   000E                  ; LD A,CHR_4
108   000E                  ; LD (RAM_DISPLAY+3),A
109   000E                  ; LD B,070H
110   000E
111   000E              ; Inicio do programa
112   000E              ini_program:
113   000E 21 FE 25         LD HL,VAR_VALUE_INS
114   0011 CD 7F 00         CALL sys_in_addr
115   0014 CD 41 00         CALL sys_clean_ram_disp
116   0017 3A FE 25         LD A,(VAR_VALUE_INS)
117   001A 6F               LD L,A
118   001B 3A FF 25         LD A,(VAR_VALUE_IN)
119   001E 67               LD H,A
120   001F 23               INC HL
121   0020 23               INC HL
122   0021 7D               LD A,L
123   0022 32 FE 25         LD (VAR_VALUE_INS),A
124   0025 7C               LD A,H
125   0026 32 FF 25         LD (VAR_VALUE_IN),A
126   0029              prg_loop:
127   0029 21 FE 25         LD HL,VAR_VALUE_INS
128   002C CD 51 00         CALL sys_disp_addr
129   002F 18 F8            JR prg_loop
130   0031 C3 0E 00         JP ini_program
131   0034
132   0034
133   0034 00 53 55 42      DB 0H,"SUBROUTINES",0H
133   0038 52 4F 55 54
133   003C 49 4E 45 53
133   0040 00
134   0041              ; ********************** Subroutines **********************
135   0041              ;
136   0041
137   0041              ; Subrotina de limpeza da area de memoria para o display
138   0041              ;
139   0041              sys_clean_ram_disp:                 ;Inicializa area de memoria do display
140   0041 E5               PUSH HL
141   0042 C5               PUSH BC
142   0043 21 70 27         LD HL,RAM_DISPLAY           ; Inicio da RAM para display
143   0046 06 06            LD B,06                     ; Preparar ponteiro para 6 endereços a partir do inicio da RAM para display
144   0048              .loop_clean_disp:               ; Inicializa area de memoria do display, com FFH (nenhum segmento aceso)
145   0048 36 FF            LD (HL),0FFH
146   004A 23               INC HL
147   004B 10 FB            DJNZ .loop_clean_disp
148   004D C1               POP BC
149   004E E1               POP HL
150   004F C9               RET
151   0050 00               DB 00H
152   0051
153   0051              ; Subrotina de exibição de dados no campo de endereço (sys_in_addr)
154   0051              ; HL (e HL+1) = posição de memória onde está o dado a ser exibido
155   0051              sys_disp_addr:
156   0051 C5               PUSH BC
157   0052 D5               PUSH DE
158   0053 11 73 27         LD DE,RAM_DISPLAY+3
159   0056 CD 66 00         CALL _sys_mem_conv2nibbles
160   0059 23               INC HL
161   005A 11 71 27         LD DE,RAM_DISPLAY+1
162   005D CD 66 00         CALL _sys_mem_conv2nibbles
163   0060 D1               POP DE
164   0061 C1               POP BC
165   0062 CD 10 01         CALL sys_keyb_disp
166   0065 C9               RET
167   0066
168   0066              ; Subrotina auxiliar das subrotinas de exibição no display
169   0066              ; Converte 2 nibbles de uma posição de memória em 2 bytes para exibição no display
170   0066              ; HL - Posição de entrada do dado a ser separado em nibbles
171   0066              ; DE - Posição mais alta para escrita dos dados convertidos para display
172   0066              _sys_mem_conv2nibbles
173   0066 7E               LD A,(HL)
174   0067 E6 0F            AND 0FH
175   0069 CD E3 00         CALL sys_conv_hexdisp
176   006C 79               LD A,C
177   006D 12               LD (DE),A
178   006E              ;    LD (RAM_DISPLAY+3),A
179   006E 1B               DEC DE
180   006F 7E               LD A,(HL)
181   0070 CB 3F            SRL A
182   0072 CB 3F            SRL A
183   0074 CB 3F            SRL A
184   0076 CB 3F            SRL A
185   0078 CD E3 00         CALL sys_conv_hexdisp
186   007B 79               LD A,C
187   007C 12               LD (DE),A
188   007D              ;    LD (RAM_DISPLAY+2),A
189   007D C9               RET
190   007E 00               DB 00H
191   007F
192   007F              ; Subrotina de entrada de dados no campo de endereço (sys_in_addr)
193   007F              ; O software fica preso nessa rotina até que uma tecla de 10 a 17 seja pressionada
194   007F              ; HL: Definição da primeira área de memória para uso com a entrada de dados
195   007F              ;    (4 dígitos, sequencia little endian)
196   007F              ; Teclas de 0 a F = serão reproduzidas no display e atualizam o valor em (HL)
197   007F              ; Teclas de 10 a 17 = encerram o loop da subrotina, tecla pressionada em RAM_KEYB_CONV
198   007F              ;       If !(keypress.bit7) then RST keyprsmem.bit7
199   007F              ;       If  (keypress.bit7) &&  (keyprsmem.bit7) then end
200   007F              ;       If  (keypress.bit7) && !(keyprsmem.bit7) then SET keyprsmem.bit7 and process the input
201   007F              sys_in_addr:
202   007F C5               PUSH BC                     ; Guarda na pilha valor atual de BC para poder usar BC na subrotina
203   0080 CD 41 00         CALL sys_clean_ram_disp     ; Limpa a memória de exibição no display
204   0083 3E 00            LD A,00H
205   0085 32 66 27         LD (RAM_DRAFT1),A
206   0088              .in_input_loop:
207   0088 CD 10 01         CALL sys_keyb_disp          ; Chama atualização do display e teclado
208   008B 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Recupera tecla atualmente pressionada (keypress = RAM_KEYB_CONV)
209   008E CB 7F            BIT 7,A                     ; Testa bit 7 de RAM_KEYB_CONV para verificar se alguma tecla está pressionada (keypress.bit7)
210   0090 28 44            JR Z,.in_reset_keyprsmem    ; Bit 7 keypress é zero (tecla solta): reseta bit 7 memória (keypressmem)
211   0092 3A 66 27         LD A,(RAM_DRAFT1)           ; Recupera memória de tecla pressionada (keyprsmem)
212   0095 CB 7F            BIT 7,A                     ; Testa bit 7, sinalizador de tecla pressionada anteriormente (keyprsmem.bit7)
213   0097 20 EF            JR NZ,.in_input_loop        ; bit 7 memória não zero (setado): não faz nada, finaliza a subrotina
214   0099 CB FF            SET 7,A                     ; Seta bit 7 e segue com o processamento da tecla pressionada
215   009B 32 66 27         LD (RAM_DRAFT1),A           ; Salva na memória de tecla pressionada (keyprsmem), que há uma tecla pressionada (bit 7 setado)
216   009E 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Recupera tecla atualmente pressionada (keypress = RAM_KEYB_CONV)
217   00A1 CB BF            RES 7,A
218   00A3 FE 10            CP 10H
219   00A5 38 02            JR C,.in_num_key
220   00A7 18 37            JR .in_addr_end
221   00A9              .in_num_key:
222   00A9 CD E3 00         CALL sys_conv_hexdisp       ; Converte o código da tecla hex (= A) em código de exibição correspondente no display -> C
223   00AC CD F6 00         CALL sys_shift_disp_left    ; Desloca no display 1 dígito para esquerda e acrescenta novo dígito contido em C
224   00AF                                              ; Atualização do valor na variável apontada por HL, suponha dado 16 bits = "WX YZ"
225   00AF 4F               LD C,A                      ; Guarda o valor digitado em C para poder usar o A, suponha valor digitado = "0K"
226   00B0 23               INC HL                      ; Vai para a parte mais significativa dos 16 bits
227   00B1 7E               LD A,(HL)                   ; Lê o dado da parte mais significativa -> "WX"
228   00B2 CB 27            SLA A                       ; Desloca parte mais significativa para esquerda -> "X0"
229   00B4 CB 27            SLA A
230   00B6 CB 27            SLA A
231   00B8 CB 27            SLA A
232   00BA 47               LD B,A                      ; Guarda valor deslocado em B -> B = "X0"
233   00BB 2B               DEC HL                      ; Coloca ponteiro na parte menos significativa
234   00BC 7E               LD A,(HL)                   ; Lê o dado da parte menos significativa -> A = "YZ"
235   00BD CB 3F            SRL A                       ; Desloca parte menos significativa para direita -> A = "0Y"
236   00BF CB 3F            SRL A
237   00C1 CB 3F            SRL A
238   00C3 CB 3F            SRL A
239   00C5 B0               OR B                        ; Combina partes deslocadas A e B -> "X0" OR "0Y" = "XY"
240   00C6 23               INC HL                      ; Coloca ponteiro na parte mais significativa
241   00C7 77               LD (HL),A                   ; Guarda valor combinado na parte mais significativa -> (HL) = "XY"
242   00C8 2B               DEC HL                      ; Coloca ponteiro na parte menos significativa
243   00C9 7E               LD A,(HL)                   ; Lê o dado da parte menos significativa -> A = "YZ"
244   00CA CB 27            SLA A                       ; Desloca parte menos significativa para esquerda -> A = "Z0"
245   00CC CB 27            SLA A
246   00CE CB 27            SLA A
247   00D0 CB 27            SLA A
248   00D2 B1               OR C                        ; Combina valor digitado com valor deslocado -> "Z0" OR "0K" = "ZK"
249   00D3 77               LD (HL),A                   ; Guarda valor combinado na parte menos significativa. Resultado final = "XYZK"
250   00D4 18 B2            JR .in_input_loop
251   00D6              .in_reset_keyprsmem:
252   00D6 3A 66 27         LD A,(RAM_DRAFT1)           ; HL contém a posição de memória da variável de sistema
253   00D9 CB BF            RES 7,A                     ; Reseta o bit 7, sinalizador de tecla pressionada anteriormente
254   00DB 32 66 27         LD (RAM_DRAFT1),A           ; Grava de volta na memória de sinalização de tecla pressionada anteriormente
255   00DE 18 A8            JR .in_input_loop
256   00E0              .in_addr_end:
257   00E0 C1               POP BC                      ; Recupera registrador BC
258   00E1 C9               RET
259   00E2 00               DB 00H
260   00E3
261   00E3              ; Subrotina que converte um digito hexadecimal para exibição no display (_conv_hexdisp)
262   00E3              ; A = num. hexadecimal 1 dígito
263   00E3              ; C = retorna o valor para exibição no display
264   00E3              sys_conv_hexdisp:
265   00E3 F5               PUSH AF
266   00E4 C5               PUSH BC
267   00E5 E5               PUSH HL
268   00E6 E6 0F            AND 0FH                     ; Isola o nibble menos significativo do código da tecla
269   00E8 4F               LD C,A
270   00E9 06 00            LD B,00H
271   00EB 21 C3 01         LD HL,DB_NUMCHAR
272   00EE 09               ADD HL,BC
273   00EF 7E               LD A,(HL)
274   00F0 E1               POP HL
275   00F1 C1               POP BC
276   00F2 4F               LD C,A
277   00F3 F1               POP AF
278   00F4 C9               RET
279   00F5 00               DB 00H
280   00F6
281   00F6              ; Sub-subrotina de deslocamento da memória do display (RAM_DISPLAY) em 1 dígito para esquerda
282   00F6              ; C = valor a ser inserido
283   00F6              sys_shift_disp_left:
284   00F6 E5               PUSH HL
285   00F7 D5               PUSH DE
286   00F8 C5               PUSH BC
287   00F9 21 70 27         LD HL,RAM_DISPLAY
288   00FC 54               LD D,H
289   00FD 5D               LD E,L
290   00FE 23               INC HL
291   00FF 0E 03            LD C,03
292   0101 06 00            LD B,00
293   0103 ED B0            LDIR
294   0105 13               INC DE
295   0106 C1               POP BC
296   0107 F5               PUSH AF
297   0108 2B               DEC HL
298   0109 79               LD A,C
299   010A 77               LD (HL),A
300   010B F1               POP AF
301   010C D1               POP DE
302   010D E1               POP HL
303   010E C9               RET
304   010F 00               DB 00H
305   0110
306   0110              ; Subrotina de atualização do display/teclado (sys_keyb_disp)
307   0110              ; Dados relevantes
308   0110              ; (RAM_DISPLAY) = Inicio da sequencia das 6 posições de memória lidas pelo sistema para exibição no display
309   0110              ;                 Dado gravado nas posições de memória são o estado de cada segmento do display
310   0110              ; (RAM_KEYB_CONV) = Posição de memória onde é armazenado o código da tecla apertada e se há uma tecla apertada
311   0110              ;                   Bits (1 byte):  P X X X K K K K
312   0110              ;                   P: Se 1, alguma tecla pressionada; Se 0, nenhuma tecla pressionada
313   0110              ;                   X: "Don't care" (sem função)
314   0110              ;                   KKKK: 1 nibble do código de tecla cf. abaixo:
315   0110              ;                   0 a 9H: Teclas "0" a "9" pressionadas (com o bit P)
316   0110              ;                   A a FH: Teclas "A" a "F" pressionadas (com o bit P)
317   0110              ;                   10H: Tecla "ADR"
318   0110              ;                   11H: Tecla "DAT"
319   0110              ;                   12H: Tecla "-"
320   0110              ;                   13H: Tecla "+"
321   0110              ;                   14H: Tecla "GO"
322   0110              ;                   15H: Tecla "REG"
323   0110              ;                   16H: Tecla "IV"
324   0110              ;                   17H: Tecla Vazia
325   0110              sys_keyb_disp:
326   0110 C5               PUSH BC
327   0111 E5               PUSH HL
328   0112 3E 00            LD A,00
329   0114 32 6D 27         LD (RAM_KEYB_CONV),A        ; Limpa variável de memória do teclado antes de ler o teclado
330   0117 3E 01            LD A,01H                    ; Ajusta A para apontar para a primeira coluna de displays (mais significativa)
331   0119 21 70 27         LD HL,RAM_DISPLAY           ; Carrega no ponteiro HL primeiro endereço da RAM de sistema para o display
332   011C              .keyb_disp_loop:
333   011C D3 03            OUT (SEL_DISP),A            ; Seleciona display apontado por A
334   011E 4F               LD C,A                      ; Guarda o valor de A
335   011F 3E FF            LD A,0FFH
336   0121 D3 01            OUT (DISP),A
337   0123                  ;LD B, 1
338   0123                  ;CALL sys_delay_ms
339   0123 DB 01            IN A,(KEYB)                 ; Lê o teclado na coluna atual
340   0125 FE 00            CP 00
341   0127 28 7A            JR Z,.wr_display            ; Se nada foi lido do teclado (nenhuma tecla apertada), vai para a atualização do display direto
342   0129 32 6E 27         LD (RAM_KEYBOARD),A         ; Se algo foi lido do teclado, registra tecla para a coluna atual
343   012C 79               LD A,C                      ; Recupera dado de qual coluna está sendo atualizada
344   012D 32 6F 27         LD (RAM_KEYB_COL),A         ; Registra na memória de qual coluna é a tecla apertada
345   0130              .keyb_disp_cnv:
346   0130 3A 6E 27         LD A,(RAM_KEYBOARD)         ; Converte posição da tecla no valor correspondente que representa (função da tecla)
347   0133 FE 01            CP 01                       ; Não foi considerada ainda a coluna nesse ponto
348   0135 CA 5C 01         JP Z,.keyb_disp_num_0
349   0138 FE 02            CP 02
350   013A CA 61 01         JP Z,.keyb_disp_num_1
351   013D FE 04            CP 04
352   013F CA 66 01         JP Z,.keyb_disp_num_2
353   0142 FE 08            CP 08
354   0144 CA 6B 01         JP Z,.keyb_disp_num_3
355   0147 FE 10            CP 16
356   0149 CA 70 01         JP Z,.keyb_disp_num_4
357   014C FE 20            CP 32
358   014E CA 75 01         JP Z,.keyb_disp_num_5
359   0151 FE 40            CP 64
360   0153 CA 7A 01         JP Z,.keyb_disp_num_6
361   0156 FE 80            CP 128
362   0158 CA 7F 01         JP Z,.keyb_disp_num_7
363   015B C9               RET
364   015C              .keyb_disp_num_0:
365   015C 3E 00            LD A,00H
366   015E 47               LD B,A
367   015F 18 21            JR .keyb_col
368   0161              .keyb_disp_num_1:
369   0161 3E 01            LD A,01H
370   0163 47               LD B,A
371   0164 18 1C            JR .keyb_col
372   0166              .keyb_disp_num_2:
373   0166 3E 02            LD A,02H
374   0168 47               LD B,A
375   0169 18 17            JR .keyb_col
376   016B              .keyb_disp_num_3:
377   016B 3E 03            LD A,03H
378   016D 47               LD B,A
379   016E 18 12            JR .keyb_col
380   0170              .keyb_disp_num_4:
381   0170 3E 04            LD A,04H
382   0172 47               LD B,A
383   0173 18 0D            JR .keyb_col
384   0175              .keyb_disp_num_5:
385   0175 3E 05            LD A,05H
386   0177 47               LD B,A
387   0178 18 08            JR .keyb_col
388   017A              .keyb_disp_num_6:
389   017A 3E 06            LD A,06H
390   017C 47               LD B,A
391   017D 18 03            JR .keyb_col
392   017F              .keyb_disp_num_7:
393   017F 3E 07            LD A,07H
394   0181 47               LD B,A
395   0182              .keyb_col:
396   0182 3A 6F 27         LD A,(RAM_KEYB_COL)         ; Decodifica a coluna e calcula o código correto da tecla (0~7H: coluna 1, 8~FH: coluna 2; 10~17H: coluna 3)
397   0185 FE 01            CP 01
398   0187 28 0A            JR Z,.keyb_cnv_plus0
399   0189 FE 02            CP 02
400   018B 28 09            JR Z,.keyb_cnv_plus8
401   018D FE 04            CP 04
402   018F 28 0A            JR Z,.keyb_cnv_plus16
403   0191 18 10            JR .wr_display
404   0193              .keyb_cnv_plus0:                ; Identificado como tecla da coluna 1 (0~7H)
405   0193 78               LD A,B
406   0194 18 08            JR .keyb_cnv_end
407   0196              .keyb_cnv_plus8:                ; Identificado como tecla da coluna 2 (8~FH)
408   0196 78               LD A,B
409   0197 C6 08            ADD A,08
410   0199 18 03            JR .keyb_cnv_end
411   019B              .keyb_cnv_plus16:               ; Identificado como tecla da coluna 1 (10~17H)
412   019B 78               LD A,B
413   019C C6 10            ADD A,16
414   019E              .keyb_cnv_end:
415   019E CB FF            SET 7,A                     ; Seta o bit 7 do valor convertido para dizer que a tecla foi lida, especialmente no caso do zero (0H)
416   01A0 32 6D 27         LD (RAM_KEYB_CONV),A
417   01A3              .wr_display:
418   01A3 7E               LD A,(HL)
419   01A4 D3 01            OUT (DISP),A
420   01A6 06 02            LD B, 2
421   01A8 CD B7 01         CALL sys_delay_ms
422   01AB 23               INC HL
423   01AC 79               LD A,C
424   01AD 87               ADD A,A
425   01AE FE 40            CP 64
426   01B0 C2 1C 01         JP NZ, .keyb_disp_loop      ; Se não chegou na última coluna de atualização do display (64), vai para o próximo loop
427   01B3 E1               POP HL
428   01B4 C1               POP BC
429   01B5 C9               RET
430   01B6 00               DB 00H
431   01B7
432   01B7              ; Delay (operative, ms) for clk = 2 MHz (sys_delay_ms);
433   01B7              ; Input: B = delay time (ms) 0,5% ;
434   01B7              ; Affects registers A, B, F
435   01B7              sys_delay_ms:
436   01B7 F5               PUSH AF
437   01B8              .delay_mult:
438   01B8 78               LD A, B
439   01B9 06 98            LD B, 152                ;Number of loops adjusted to A = delay ms with minimum error
440   01BB              .delay_1ms:
441   01BB 10 FE            DJNZ .delay_1ms
442   01BD 47               LD B, A
443   01BE 10 F8            DJNZ .delay_mult
444   01C0 F1               POP AF
445   01C1 C9               RET
446   01C2 00               DB 00H
447   01C3
448   01C3              ; Código dos caracteres para exibição no display em sequencia de endereços para facilitar a conversão numérica
449   01C3              DB_NUMCHAR EQU $
450   01C3 C0               DB      0C0H                ; Caractere 0
451   01C4 F9               DB      0F9H                ; Caractere 1
452   01C5 A4               DB      0A4H                ; Caractere 2
453   01C6 B0               DB      0B0H                ; Caractere 3
454   01C7 99               DB      099H                ; Caractere 4
455   01C8 92               DB      092H                ; Caractere 5
456   01C9 82               DB      082H                ; Caractere 6
457   01CA F8               DB      0F8H                ; Caractere 7
458   01CB 80               DB      080H                ; Caractere 8
459   01CC 90               DB      090H                ; Caractere 9
460   01CD 88               DB      088H                ; Caractere A
461   01CE 83               DB      083H                ; Caractere B
462   01CF C6               DB      0C6H                ; Caractere C
463   01D0 A1               DB      0A1H                ; Caractere D
464   01D1 86               DB      086H                ; Caractere E
465   01D2 8E               DB      08EH                ; Caractere F
466   01D3 FF               DB      0FFH                ; Tecla especial 1
467   01D4 FF               DB      0FFH                ; Tecla especial 2
468   01D5 FF               DB      0FFH                ; Tecla especial 3
469   01D6 FF               DB      0FFH                ; Tecla especial 4
470   01D7 FF               DB      0FFH                ; Tecla especial 5
471   01D8 FF               DB      0FFH                ; Tecla especial 6
472   01D9 FF               DB      0FFH                ; Tecla especial 7
473   01DA FF               DB      0FFH                ; Tecla especial 8
474   01DB
# file closed: NEMO-80.asm
