# file opened: NEMO-80.asm
  1   0000              ;===========================================================================
  2   0000              ; Thiago Turcato do Rego - 2023
  3   0000              ; Project: NEMO-80, New Monitor for CEDM-80
  4   0000              ; File: NEMO-80.asm
  5   0000              ;===========================================================================
  6   0000
  7   0000              ;============ TERMINOLOGY, CONVENTIONS AND ORGANIZATION ====================
  8   0000              ; -- TERMINOLOGIES --
  9   0000              ; subr.  = subroutines
 10   0000              ; drcly = directly
 11   0000              ; aux. = auxiliary
 12   0000              ;
 13   0000              ; -- SYMBOLS CONVENTIONS --
 14   0000              ; - Symbols in UPPER CASE LETTERS = constants
 15   0000              ; - Labels starting with "." are local jump entry points
 16   0000              ; - Labels starting with "_" are local subroutines (aux. subr.)
 17   0000              ; - Labels starting with lower case letters (except for the cases below)
 18   0000              ;    are general function calls, open to any user
 19   0000              ; - Labels starting with "dmsg_" are ascii text formated messages to use
 20   0000              ;    for display (user interface messages)
 21   0000              ;
 22   0000              ;=============================================================================
 23   0000
 24   0000              ; Compilation directives for allocating memory (no bank) and SLD file generation
 25   0000               DEVICE NOSLOT64K
 26   0000               SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
 27   0000
 28   0000              ;******** Constants definition ********
 29   0000              ; ROM first address and size (2 KiB = 2048 bytes, 0000H ~ 07FFH)
 30   0000              ROMBEGIN        EQU 0000H
 31   0000              ROMSIZE         EQU 800H
 32   0000
 33   0000              ; RAM first address and size (2 KiB = 2048 bytes, 2000H ~ 27FFH)
 34   0000              RAMBEGIN        EQU 2000H
 35   0000              RAMSIZE         EQU 800H
 36   0000
 37   0000              ; Constants
 38   0000              CHR_0           EQU 0C0H
 39   0000              CHR_1           EQU 0F9H
 40   0000              CHR_2           EQU 0A4H
 41   0000              CHR_3           EQU 0B0H
 42   0000              CHR_4           EQU 099H
 43   0000              CHR_5           EQU 092H
 44   0000              CHR_6           EQU 082H
 45   0000              CHR_7           EQU 0F8H
 46   0000              CHR_8           EQU 080H
 47   0000              CHR_9           EQU 090H
 48   0000              CHR_A           EQU 088H
 49   0000              CHR_B           EQU 083H
 50   0000              CHR_C           EQU 0C6H
 51   0000              CHR_D           EQU 0A1H
 52   0000              CHR_E           EQU 086H
 53   0000              CHR_F           EQU 08EH
 54   0000              ;....
 55   0000              CHR_N           EQU 0C8H
 56   0000              CHR_M           EQU 0AAH
 57   0000              CHR_O           EQU 0C0H
 58   0000
 59   0000              ; I/O addresses
 60   0000              DISP            EQU 01H
 61   0000              SEL_DISP        EQU 03H
 62   0000              KEYB            EQU 01H
 63   0000
 64   0000              ; RESERVADO PARA SISTEMA: END. 2600H ~ 27FF
 65   0000
 66   0000              ; RAM para sistema até 27FF
 67   0000              RAM_SYS_START   EQU 2600H    ; Inicio da área de RAM reservada para sistema
 68   0000
 69   0000              RAM_DRAFT1      EQU 2766H    ; Área de rascunho para as subrotinas
 70   0000              RAM_DRAFT2      EQU 2767H    ; Área de rascunho para as subrotinas
 71   0000              RAM_DRAFT3      EQU 2768H    ; Área de rascunho para as subrotinas
 72   0000              RAM_DRAFT4      EQU 2769H    ; Área de rascunho para as subrotinas
 73   0000              RAM_DRAFT5      EQU 276AH    ; Área de rascunho para as subrotinas
 74   0000              RAM_DRAFT6      EQU 276BH    ; Área de rascunho para as subrotinas
 75   0000              RAM_DRAFT7      EQU 276CH    ; Área de rascunho para as subrotinas
 76   0000              RAM_KEYB_CONV   EQU 276DH    ; Código da tecla pressionada já decodificado de 00 a 17 (24 teclas)
 77   0000              RAM_KEYBOARD    EQU 276EH    ; Valor binário na matriz da tecla pressionada
 78   0000              RAM_KEYB_COL    EQU 276FH    ; Coluna selecionada na varredura do teclado
 79   0000              RAM_DISPLAY     EQU 2770H    ; Caracteres a serem exibidos no display pos. 2770H a 2775H
 80   0000
 81   0000              ; Stack = 2780H a 27FFH
 82   0000              RAM_STACK_0     EQU 2780H
 83   0000              RAM_STACK_127   EQU 27FFH
 84   0000
 85   0000              ; Variáveis do programa, do endereço 25FF para trás (128 bytes)
 86   0000              VAR_TEST        EQU 25FCH
 87   0000
 88   0000              VAR_CURR_DATA   EQU 25FDH
 89   0000              VAR_CURR_ADDRL  EQU 25FEH
 90   0000              VAR_CURR_ADDRH  EQU 25FFH
 91   0000
 92   0000              ;******** Beggining of monitor program ********
 93   0000                  ORG ROMBEGIN
 94   0000
 95   0000              ; ********************** Programa principal **********************
 96   0000              ; Ajustes e configuração iniciais
 97   0000 31 FF 27         LD SP, 27FFH                ; Ajusta o stack pointer no fim da memória RAM. Considerado 128 bytes de stack 2780 até 27FF
 98   0003
 99   0003              ; Inicializações antes do programa
100   0003              initialization:
101   0003 CD AE 00         CALL sys_clean_ram_disp     ; Limpa a memória de exibição no display
102   0006
103   0006              ; Inicio do programa
104   0006              ini_program:
105   0006 3E C8            LD A,CHR_N                  ; Mensagem de inicialização NEMO-80
106   0008 32 70 27         LD (RAM_DISPLAY),A
107   000B 3E 86            LD A,CHR_E
108   000D 32 71 27         LD (RAM_DISPLAY+1),A
109   0010 3E AA            LD A,CHR_M
110   0012 32 72 27         LD (RAM_DISPLAY+2),A
111   0015 3E C0            LD A,CHR_O
112   0017 32 73 27         LD (RAM_DISPLAY+3),A
113   001A 3E 80            LD A,CHR_8
114   001C 32 74 27         LD (RAM_DISPLAY+4),A
115   001F 3E C0            LD A,CHR_0
116   0021 32 75 27         LD (RAM_DISPLAY+5),A
117   0024
118   0024              loop_main_menu:                 ; Rotina de menu inicial
119   0024 CD 18 02         CALL sys_keyb_disp
120   0027 3A 6D 27         LD A,(RAM_KEYB_CONV)
121   002A CB BF            RES 7,A
122   002C FE 10            CP 10H                       ; Se pressionada tecla ADR, chama entrada de endereço
123   002E CC 40 00         CALL Z, menu_addr
124   0031                  ; IMPLEMENTAÇÃO A CONTINUAR DAQUI! TODO 15/04/2024
125   0031 18 F1            JR loop_main_menu
126   0033
127   0033 00 53 55 42      DB 0H,"SUBROUTINES",0H
127   0037 52 4F 55 54
127   003B 49 4E 45 53
127   003F 00
128   0040              ; ********************** Subroutines **********************
129   0040              ;
130   0040
131   0040              ; Subrotina de edição/exibição da memória
132   0040              menu_addr:
133   0040 CD AE 00         CALL sys_clean_ram_disp     ; Limpa a memória do display
134   0043 CD 06 01         CALL sys_wait_keyrelease    ; Aguarda a tecla ADR ser solta
135   0046              menu_addr_in:
136   0046 3E 00            LD A,00H                    ; Zera as variáveis de posição de memória a ser lida ou alterada
137   0048 32 FE 25         LD (VAR_CURR_ADDRL),A
138   004B 32 FF 25         LD (VAR_CURR_ADDRH),A
139   004E 21 FE 25         LD HL,VAR_CURR_ADDRL        ; Carrega como ponteiro, o endereço da variável da posição de memória a ler/alterar
140   0051 CD 62 01         CALL sys_in_addr            ; Chama a rotina de entrada de valor do endereço
141   0054              menu_wait_keypress:
142   0054 CD FA 00         CALL sys_wait_keypress      ; Depois da entrada do endereço, aguarda tecla DAT para entrada de dados ser pressionada ou outra para sair
143   0057 CB BF            RES 7,A                     ; Reseta o bit de tecla pressionada do reg. A
144   0059 FE 11            CP 11H                      ; Se pressionada tecla DAT, chama entrada de dados
145   005B 28 36            JR Z, menu_addr_data
146   005D FE 12            CP 12H                      ; Se pressionada tecla "-", chama entrada de endereço
147   005F 28 02            JR Z, menu_addr_minus
148   0061 18 0F            JR menu_addr_isplus
149   0063              menu_addr_minus:
150   0063 2A FE 25         LD HL,(VAR_CURR_ADDRL)
151   0066 2B               DEC HL
152   0067 22 FE 25         LD (VAR_CURR_ADDRL),HL
153   006A CD 06 01         CALL sys_wait_keyrelease
154   006D 21 FE 25         LD HL,VAR_CURR_ADDRL        ; Carrega como ponteiro, o endereço da variável da posição de memória a ler/alterar
155   0070 18 21            JR menu_addr_data
156   0072              menu_addr_isplus:
157   0072 FE 13            CP 13H                      ; Se pressionada tecla "+", chama entrada de endereço
158   0074 28 02            JR Z, menu_addr_plus
159   0076 18 0F            JR menu_addr_isgo
160   0078              menu_addr_plus:
161   0078 2A FE 25         LD HL,(VAR_CURR_ADDRL)
162   007B 23               INC HL
163   007C 22 FE 25         LD (VAR_CURR_ADDRL),HL
164   007F CD 06 01         CALL sys_wait_keyrelease
165   0082 21 FE 25         LD HL,VAR_CURR_ADDRL        ; Carrega como ponteiro, o endereço da variável da posição de memória a ler/alterar
166   0085 18 0C            JR menu_addr_data
167   0087              menu_addr_isgo:
168   0087 FE 14            CP 14H                      ; Se pressionada tecla "GO", chama execução no endereço atual
169   0089 28 02            JR Z, menu_addr_go
170   008B 18 04            JR menu_addr_otherkey
171   008D              menu_addr_go:
172   008D 2A FE 25         LD HL,(VAR_CURR_ADDRL)
173   0090 E9               JP HL
174   0091              menu_addr_otherkey:
175   0091 18 17            JR menu_addr_end            ; Se outra tecla foi pressionada, que não seja "DAT", "+", "-" ou "GO", finaliza a entrada de endereço
176   0093              menu_addr_data:
177   0093 21 FE 25         LD HL,VAR_CURR_ADDRL        ; Carrega como ponteiro, o endereço da variável da posição de memória a ler/alterar
178   0096 CD CC 00         CALL sys_disp_addr
179   0099 2A FE 25         LD HL,(VAR_CURR_ADDRL)
180   009C CD BE 00         CALL sys_disp_data
181   009F CD 06 01         CALL sys_wait_keyrelease
182   00A2 CD FA 00         CALL sys_wait_keypress
183   00A5 CD 12 01         CALL sys_in_data
184   00A8 18 AA            JR menu_wait_keypress
185   00AA              menu_addr_end:
186   00AA 3E FF            LD A,0FFH
187   00AC C9               RET
188   00AD 00               DB 00H
189   00AE
190   00AE              ; Subrotina de limpeza da area de memoria para o display
191   00AE              ;
192   00AE              sys_clean_ram_disp:             ;Inicializa area de memoria do display
193   00AE E5               PUSH HL
194   00AF C5               PUSH BC
195   00B0 21 70 27         LD HL,RAM_DISPLAY           ; Inicio da RAM para display
196   00B3 06 06            LD B,06                     ; Preparar ponteiro para 6 endereços a partir do inicio da RAM para display
197   00B5              .loop_clean_disp:               ; Inicializa area de memoria do display, com FFH (nenhum segmento aceso)
198   00B5 36 FF            LD (HL),0FFH                ; Limpa a exibição no display escrevendo 0FFH na posição de memória
199   00B7 23               INC HL                      ; Coloca o ponteiro na próxima posição de memória
200   00B8 10 FB            DJNZ .loop_clean_disp       ; Decrementa o reg. B e, se não for zero, continua o loop de limpeza da memória
201   00BA C1               POP BC
202   00BB E1               POP HL
203   00BC C9               RET
204   00BD 00               DB 00H
205   00BE
206   00BE              ; Subrotina de exibição de dados no campo de dados (sys_disp_data)
207   00BE              ; HL (e HL+1) = posição de memória onde está o dado a ser exibido
208   00BE              sys_disp_data:
209   00BE C5               PUSH BC                     ; Reserva o valor de BC (C é usado na subrotina _sys_mem_conv2nibbles)
210   00BF D5               PUSH DE
211   00C0 11 75 27         LD DE,RAM_DISPLAY+5         ; Coloca o ponteiro DE no 4.o display da esq. para a direita
212   00C3 CD E1 00         CALL _sys_mem_conv2nibbles  ; Chama função que converte os dois nibbles (LSB) do dado apontado por HL em caracteres para o display
213   00C6 D1               POP DE
214   00C7 C1               POP BC
215   00C8 CD 18 02         CALL sys_keyb_disp          ; Exibe no display o valor do endereço
216   00CB C9               RET
217   00CC
218   00CC              ; Subrotina de exibição de dados no campo de endereço (sys_disp_addr)
219   00CC              ; HL (e HL+1) = posição de memória onde está o dado a ser exibido
220   00CC              sys_disp_addr:
221   00CC C5               PUSH BC                     ; Reserva o valor de BC (C é usado na subrotina _sys_mem_conv2nibbles)
222   00CD D5               PUSH DE
223   00CE 11 73 27         LD DE,RAM_DISPLAY+3         ; Coloca o ponteiro DE no 4.o display da esq. para a direita
224   00D1 CD E1 00         CALL _sys_mem_conv2nibbles  ; Chama função que converte os dois nibbles (LSB) do dado apontado por HL em caracteres para o display
225   00D4 23               INC HL                      ; Coloca ponteiro HL na próxima posição da variável de dado
226   00D5 11 71 27         LD DE,RAM_DISPLAY+1         ; Coloca o ponteiro DE no 2.o display da esq. para a direita
227   00D8 CD E1 00         CALL _sys_mem_conv2nibbles  ; Chama função que converte os dois nibbles (MSB) do dado apontado por HL em caracteres para o display
228   00DB D1               POP DE
229   00DC C1               POP BC
230   00DD CD 18 02         CALL sys_keyb_disp          ; Exibe no display o valor do endereço
231   00E0 C9               RET
232   00E1
233   00E1              ; Subrotina auxiliar das subrotinas de exibição no display
234   00E1              ; Converte 2 nibbles de uma posição de memória em 2 bytes para exibição no display
235   00E1              ; HL - Posição de entrada do dado a ser separado em nibbles
236   00E1              ; DE - Posição mais alta para escrita dos dados convertidos para display
237   00E1              _sys_mem_conv2nibbles
238   00E1 7E               LD A,(HL)
239   00E2 E6 0F            AND 0FH
240   00E4 CD D1 01         CALL sys_conv_hexdisp
241   00E7 79               LD A,C
242   00E8 12               LD (DE),A
243   00E9 1B               DEC DE
244   00EA 7E               LD A,(HL)
245   00EB CB 3F            SRL A
246   00ED CB 3F            SRL A
247   00EF CB 3F            SRL A
248   00F1 CB 3F            SRL A
249   00F3 CD D1 01         CALL sys_conv_hexdisp
250   00F6 79               LD A,C
251   00F7 12               LD (DE),A
252   00F8 C9               RET
253   00F9 00               DB 00H
254   00FA
255   00FA              ; Subrotina para aguardar em loop uma tecla ser pressionada
256   00FA              ; A : Código da tecla + bit de tecla pressionada
257   00FA              sys_wait_keypress
258   00FA CD 18 02         CALL sys_keyb_disp          ; Exibe display e lê teclado
259   00FD 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Lê a memória de tecla lida
260   0100 CB 7F            BIT 7,A                     ; Verifica se alguma tecla foi pressionada (digitação de um endereço, p. ex.)
261   0102 28 F6            JR Z,sys_wait_keypress      ; Fica em loop até uma tecla ser pressionada
262   0104 C9               RET
263   0105 00               DB 00H
264   0106
265   0106              ; Subrotina para aguardar em loop uma tecla ser solta
266   0106              ; A : Código da tecla + bit de tecla pressionada
267   0106              sys_wait_keyrelease
268   0106 CD 18 02         CALL sys_keyb_disp          ; Exibe display e lê teclado
269   0109 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Lê a memória de tecla lida
270   010C CB 7F            BIT 7,A
271   010E C8               RET Z                       ; Verifica se alguma tecla foi pressionada (digitação de um endereço, p. ex.)
272   010F 18 F5            JR sys_wait_keyrelease      ; Fica em loop até uma tecla ser pressionada
273   0111 00               DB 00H
274   0112
275   0112              ; Subrotina de entrada de valor no campo de dados (sys_in_data)
276   0112              ; O software fica preso nessa rotina até que uma tecla de 10 a 17 seja pressionada
277   0112              ; HL: Definição da primeira área de memória para uso com a entrada de dados (2 dígitos)
278   0112              ; Teclas de 0 a F = serão reproduzidas no display e atualizam o valor em (HL)
279   0112              ; Teclas de 10 a 17 = encerram o loop da subrotina, tecla pressionada em RAM_KEYB_CONV
280   0112              ;       If !(keypress.bit7) then RST keyprsmem.bit7
281   0112              ;       If  (keypress.bit7) &&  (keyprsmem.bit7) then end
282   0112              ;       If  (keypress.bit7) && !(keyprsmem.bit7) then SET keyprsmem.bit7 and process the input
283   0112              sys_in_data:
284   0112 C5               PUSH BC                     ; Guarda na pilha valor atual de BC para poder usar BC na subrotina
285   0113 3E FF            LD A,0FFH
286   0115 32 74 27         LD (RAM_DISPLAY+4),A        ; Limpa memória de exibição do 5.o display de endereçamento
287   0118 32 75 27         LD (RAM_DISPLAY+5),A        ; Limpa memória de exibição do 6.o display de endereçamento
288   011B 3E 00            LD A,00H
289   011D 32 66 27         LD (RAM_DRAFT1),A
290   0120              .in_data_input_loop:
291   0120 CD 18 02         CALL sys_keyb_disp          ; Chama atualização do display e teclado
292   0123 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Recupera tecla atualmente pressionada (keypress = RAM_KEYB_CONV)
293   0126 CB 7F            BIT 7,A                     ; Testa bit 7 de RAM_KEYB_CONV para verificar se alguma tecla está pressionada (keypress.bit7)
294   0128 28 2B            JR Z,.in_data_rst_keyprsmem ; Bit 7 keypress é zero (tecla solta): reseta bit 7 memória (keypressmem)
295   012A 3A 66 27         LD A,(RAM_DRAFT1)           ; Recupera memória de tecla pressionada (keyprsmem)
296   012D CB 7F            BIT 7,A                     ; Testa bit 7, sinalizador de tecla pressionada anteriormente (keyprsmem.bit7)
297   012F 20 EF            JR NZ,.in_data_input_loop   ; bit 7 memória não zero (setado): não faz nada, finaliza a subrotina
298   0131 CB FF            SET 7,A                     ; Seta bit 7 e segue com o processamento da tecla pressionada
299   0133 32 66 27         LD (RAM_DRAFT1),A           ; Salva na memória de tecla pressionada (keyprsmem), que há uma tecla pressionada (bit 7 setado)
300   0136 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Recupera tecla atualmente pressionada (keypress = RAM_KEYB_CONV)
301   0139 CB BF            RES 7,A                     ; Reseta o bit 7 no registrador A para testar se a tecla é numérica ou de função
302   013B FE 10            CP 10H                      ; Compara o código da tecla com 10H (16)
303   013D 38 02            JR C,.in_data_num_key       ; Se for menor que 16, a tecla é numérica, segue para o processamento da entrada numérica
304   013F 18 1E            JR .in_data_end             ; Se for maior ou igual a 16, a tecla é de função, encerra o loop de entrada numérica
305   0141              .in_data_num_key:
306   0141 CD D1 01         CALL sys_conv_hexdisp       ; Converte o código da tecla hex (= A) em código de exibição correspondente no display -> C
307   0144 CD FE 01         CALL sys_sftl_data_disp     ; Desloca no display 1 dígito para esquerda e acrescenta novo dígito contido em C
308   0147                                              ; Atualização do valor na variável apontada por HL, suponha dado 8 bits = "XY"
309   0147 4F               LD C,A                      ; Guarda o valor digitado em C para poder usar o A, suponha valor digitado = "0K"
310   0148 7E               LD A,(HL)                   ; Lê o dado da parte menos significativa -> A = "XY"
311   0149 CB 27            SLA A                       ; Desloca parte menos significativa para esquerda -> A = "Y0"
312   014B CB 27            SLA A
313   014D CB 27            SLA A
314   014F CB 27            SLA A
315   0151 B1               OR C                        ; Combina valor digitado com valor deslocado -> "Y0" OR "0K" = "YK"
316   0152 77               LD (HL),A                   ; Guarda valor combinado na parte menos significativa. Resultado final = "YK"
317   0153 18 CB            JR .in_data_input_loop      ; Retorna ao inicio da subrotina de entrada para testar se há próximo digito de entrada
318   0155              .in_data_rst_keyprsmem:
319   0155 3A 66 27         LD A,(RAM_DRAFT1)           ; HL contém a posição de memória da variável de sistema
320   0158 CB BF            RES 7,A                     ; Reseta o bit 7, sinalizador de tecla pressionada anteriormente
321   015A 32 66 27         LD (RAM_DRAFT1),A           ; Grava de volta na memória de sinalização de tecla pressionada anteriormente
322   015D 18 C1            JR .in_data_input_loop      ; Retorna ao inicio da subrotina de entrada para testar se há próximo digito de entrada
323   015F              .in_data_end:
324   015F C1               POP BC                      ; Recupera registrador BC
325   0160 C9               RET
326   0161 00               DB 00H
327   0162
328   0162              ; Subrotina de entrada de valor no campo de endereço (sys_in_addr)
329   0162              ; O software fica preso nessa rotina até que uma tecla de 10 a 17 seja pressionada
330   0162              ; HL: Definição da primeira área de memória para uso com a entrada de dados
331   0162              ;    (4 dígitos, sequencia little endian)
332   0162              ; Teclas de 0 a F = serão reproduzidas no display e atualizam o valor em (HL)
333   0162              ; Teclas de 10 a 17 = encerram o loop da subrotina, tecla pressionada em RAM_KEYB_CONV
334   0162              ;       If !(keypress.bit7) then RST keyprsmem.bit7
335   0162              ;       If  (keypress.bit7) &&  (keyprsmem.bit7) then end
336   0162              ;       If  (keypress.bit7) && !(keyprsmem.bit7) then SET keyprsmem.bit7 and process the input
337   0162              sys_in_addr:
338   0162 C5               PUSH BC                     ; Guarda na pilha valor atual de BC para poder usar BC na subrotina
339   0163 3E FF            LD A,0FFH
340   0165 32 70 27         LD (RAM_DISPLAY),A          ; Limpa memória de exibição do 1.o display de endereçamento
341   0168 32 71 27         LD (RAM_DISPLAY+1),A        ; Limpa memória de exibição do 2.o display de endereçamento
342   016B 32 72 27         LD (RAM_DISPLAY+2),A        ; Limpa memória de exibição do 3.o display de endereçamento
343   016E 32 73 27         LD (RAM_DISPLAY+3),A        ; Limpa memória de exibição do 4.o display de endereçamento
344   0171              ;    CALL sys_clean_ram_disp     ; Limpa a memória de exibição no display
345   0171 3E 00            LD A,00H
346   0173 32 66 27         LD (RAM_DRAFT1),A
347   0176              .in_addr_input_loop:
348   0176 CD 18 02         CALL sys_keyb_disp          ; Chama atualização do display e teclado
349   0179 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Recupera tecla atualmente pressionada (keypress = RAM_KEYB_CONV)
350   017C CB 7F            BIT 7,A                     ; Testa bit 7 de RAM_KEYB_CONV para verificar se alguma tecla está pressionada (keypress.bit7)
351   017E 28 44            JR Z,.in_addr_rst_keyprsmem ; Bit 7 keypress é zero (tecla solta): reseta bit 7 memória (keypressmem)
352   0180 3A 66 27         LD A,(RAM_DRAFT1)           ; Recupera memória de tecla pressionada (keyprsmem)
353   0183 CB 7F            BIT 7,A                     ; Testa bit 7, sinalizador de tecla pressionada anteriormente (keyprsmem.bit7)
354   0185 20 EF            JR NZ,.in_addr_input_loop   ; bit 7 memória não zero (setado): não faz nada, finaliza a subrotina
355   0187 CB FF            SET 7,A                     ; Seta bit 7 e segue com o processamento da tecla pressionada
356   0189 32 66 27         LD (RAM_DRAFT1),A           ; Salva na memória de tecla pressionada (keyprsmem), que há uma tecla pressionada (bit 7 setado)
357   018C 3A 6D 27         LD A,(RAM_KEYB_CONV)        ; Recupera tecla atualmente pressionada (keypress = RAM_KEYB_CONV)
358   018F CB BF            RES 7,A                     ; Reseta o bit 7 no registrador A para testar se a tecla é numérica ou de função
359   0191 FE 10            CP 10H                      ; Compara o código da tecla com 10H (16)
360   0193 38 02            JR C,.in_addr_num_key       ; Se for menor que 16, a tecla é numérica, segue para o processamento da entrada numérica
361   0195 18 37            JR .in_addr_end             ; Se for maior ou igual a 16, a tecla é de função, encerra o loop de entrada numérica
362   0197              .in_addr_num_key:
363   0197 CD D1 01         CALL sys_conv_hexdisp       ; Converte o código da tecla hex (= A) em código de exibição correspondente no display -> C
364   019A CD E4 01         CALL sys_sftl_addr_disp    ; Desloca no display 1 dígito para esquerda e acrescenta novo dígito contido em C
365   019D                                              ; Atualização do valor na variável apontada por HL, suponha dado 16 bits = "WX YZ"
366   019D 4F               LD C,A                      ; Guarda o valor digitado em C para poder usar o A, suponha valor digitado = "0K"
367   019E 23               INC HL                      ; Vai para a parte mais significativa dos 16 bits
368   019F 7E               LD A,(HL)                   ; Lê o dado da parte mais significativa -> "WX"
369   01A0 CB 27            SLA A                       ; Desloca parte mais significativa para esquerda -> "X0"
370   01A2 CB 27            SLA A
371   01A4 CB 27            SLA A
372   01A6 CB 27            SLA A
373   01A8 47               LD B,A                      ; Guarda valor deslocado em B -> B = "X0"
374   01A9 2B               DEC HL                      ; Coloca ponteiro na parte menos significativa
375   01AA 7E               LD A,(HL)                   ; Lê o dado da parte menos significativa -> A = "YZ"
376   01AB CB 3F            SRL A                       ; Desloca parte menos significativa para direita -> A = "0Y"
377   01AD CB 3F            SRL A
378   01AF CB 3F            SRL A
379   01B1 CB 3F            SRL A
380   01B3 B0               OR B                        ; Combina partes deslocadas A e B -> "X0" OR "0Y" = "XY"
381   01B4 23               INC HL                      ; Coloca ponteiro na parte mais significativa
382   01B5 77               LD (HL),A                   ; Guarda valor combinado na parte mais significativa -> (HL) = "XY"
383   01B6 2B               DEC HL                      ; Coloca ponteiro na parte menos significativa
384   01B7 7E               LD A,(HL)                   ; Lê o dado da parte menos significativa -> A = "YZ"
385   01B8 CB 27            SLA A                       ; Desloca parte menos significativa para esquerda -> A = "Z0"
386   01BA CB 27            SLA A
387   01BC CB 27            SLA A
388   01BE CB 27            SLA A
389   01C0 B1               OR C                        ; Combina valor digitado com valor deslocado -> "Z0" OR "0K" = "ZK"
390   01C1 77               LD (HL),A                   ; Guarda valor combinado na parte menos significativa. Resultado final = "XYZK"
391   01C2 18 B2            JR .in_addr_input_loop      ; Retorna ao inicio da subrotina de entrada para testar se há próximo digito de entrada
392   01C4              .in_addr_rst_keyprsmem:
393   01C4 3A 66 27         LD A,(RAM_DRAFT1)           ; HL contém a posição de memória da variável de sistema
394   01C7 CB BF            RES 7,A                     ; Reseta o bit 7, sinalizador de tecla pressionada anteriormente
395   01C9 32 66 27         LD (RAM_DRAFT1),A           ; Grava de volta na memória de sinalização de tecla pressionada anteriormente
396   01CC 18 A8            JR .in_addr_input_loop      ; Retorna ao inicio da subrotina de entrada para testar se há próximo digito de entrada
397   01CE              .in_addr_end:
398   01CE C1               POP BC                      ; Recupera registrador BC
399   01CF C9               RET
400   01D0 00               DB 00H
401   01D1
402   01D1              ; Subrotina que converte um digito hexadecimal para exibição no display (_conv_hexdisp)
403   01D1              ; A = num. hexadecimal 1 dígito
404   01D1              ; C = retorna o valor para exibição no display
405   01D1              sys_conv_hexdisp:
406   01D1 F5               PUSH AF
407   01D2 C5               PUSH BC
408   01D3 E5               PUSH HL
409   01D4 E6 0F            AND 0FH                     ; Isola o nibble menos significativo do código da tecla
410   01D6 4F               LD C,A
411   01D7 06 00            LD B,00H
412   01D9 21 CC 02         LD HL,DB_NUMCHAR
413   01DC 09               ADD HL,BC
414   01DD 7E               LD A,(HL)
415   01DE E1               POP HL
416   01DF C1               POP BC
417   01E0 4F               LD C,A
418   01E1 F1               POP AF
419   01E2 C9               RET
420   01E3 00               DB 00H
421   01E4
422   01E4              ; Sub-subrotina de deslocamento da memória do display de endereço (RAM_DISPLAY) em 1 dígito para esquerda
423   01E4              ; C = valor a ser inserido
424   01E4              sys_sftl_addr_disp:
425   01E4 E5               PUSH HL
426   01E5 D5               PUSH DE
427   01E6 C5               PUSH BC
428   01E7 21 70 27         LD HL,RAM_DISPLAY
429   01EA 54               LD D,H
430   01EB 5D               LD E,L
431   01EC 23               INC HL
432   01ED 0E 03            LD C,03
433   01EF 06 00            LD B,00
434   01F1 ED B0            LDIR
435   01F3 13               INC DE
436   01F4 C1               POP BC
437   01F5 F5               PUSH AF
438   01F6 2B               DEC HL
439   01F7 79               LD A,C
440   01F8 77               LD (HL),A
441   01F9 F1               POP AF
442   01FA D1               POP DE
443   01FB E1               POP HL
444   01FC C9               RET
445   01FD 00               DB 00H
446   01FE
447   01FE              ; Sub-subrotina de deslocamento da memória do display de dados (RAM_DISPLAY+4) em 1 dígito para esquerda
448   01FE              ; C = valor a ser inserido
449   01FE              sys_sftl_data_disp:
450   01FE E5               PUSH HL
451   01FF D5               PUSH DE
452   0200 C5               PUSH BC
453   0201 21 74 27         LD HL,RAM_DISPLAY+4
454   0204 54               LD D,H
455   0205 5D               LD E,L
456   0206 23               INC HL
457   0207 0E 01            LD C,01
458   0209 06 00            LD B,00
459   020B ED B0            LDIR
460   020D 13               INC DE
461   020E C1               POP BC
462   020F F5               PUSH AF
463   0210 2B               DEC HL
464   0211 79               LD A,C
465   0212 77               LD (HL),A
466   0213 F1               POP AF
467   0214 D1               POP DE
468   0215 E1               POP HL
469   0216 C9               RET
470   0217 00               DB 00H
471   0218
472   0218              ; Subrotina de atualização do display/teclado (sys_keyb_disp)
473   0218              ; Dados relevantes
474   0218              ; (RAM_DISPLAY) = Inicio da sequencia das 6 posições de memória lidas pelo sistema para exibição no display
475   0218              ;                 Dado gravado nas posições de memória são o estado de cada segmento do display
476   0218              ; (RAM_KEYB_CONV) = Posição de memória onde é armazenado o código da tecla apertada e se há uma tecla apertada
477   0218              ;                   Bits (1 byte):  P X X X K K K K
478   0218              ;                   P: Se 1, alguma tecla pressionada; Se 0, nenhuma tecla pressionada
479   0218              ;                   X: "Don't care" (sem função)
480   0218              ;                   KKKK: 1 nibble do código de tecla cf. abaixo:
481   0218              ;                   0 a 9H: Teclas "0" a "9" pressionadas (com o bit P)
482   0218              ;                   A a FH: Teclas "A" a "F" pressionadas (com o bit P)
483   0218              ;                   10H: Tecla "ADR"
484   0218              ;                   11H: Tecla "DAT"
485   0218              ;                   12H: Tecla "-"
486   0218              ;                   13H: Tecla "+"
487   0218              ;                   14H: Tecla "GO"
488   0218              ;                   15H: Tecla "REG"
489   0218              ;                   16H: Tecla "IV"
490   0218              ;                   17H: Tecla Vazia
491   0218              sys_keyb_disp:
492   0218 C5               PUSH BC
493   0219 E5               PUSH HL
494   021A 3E 00            LD A,00
495   021C 32 6D 27         LD (RAM_KEYB_CONV),A        ; Limpa variável de memória do teclado antes de ler o teclado
496   021F 3E 01            LD A,01H                    ; Ajusta A para apontar para a primeira coluna de displays (mais significativa)
497   0221 21 70 27         LD HL,RAM_DISPLAY           ; Carrega no ponteiro HL primeiro endereço da RAM de sistema para o display
498   0224              .keyb_disp_loop:
499   0224 D3 03            OUT (SEL_DISP),A            ; Seleciona display apontado por A
500   0226 4F               LD C,A                      ; Guarda o valor de A
501   0227 3E FF            LD A,0FFH
502   0229 D3 01            OUT (DISP),A
503   022B                  ;LD B, 1
504   022B                  ;CALL sys_delay_ms
505   022B DB 01            IN A,(KEYB)                 ; Lê o teclado na coluna atual
506   022D FE 00            CP 00
507   022F 28 7B            JR Z,.wr_display            ; Se nada foi lido do teclado (nenhuma tecla apertada), vai para a atualização do display direto
508   0231 32 6E 27         LD (RAM_KEYBOARD),A         ; Se algo foi lido do teclado, registra tecla para a coluna atual
509   0234 79               LD A,C                      ; Recupera dado de qual coluna está sendo atualizada
510   0235 32 6F 27         LD (RAM_KEYB_COL),A         ; Registra na memória de qual coluna é a tecla apertada
511   0238              .keyb_disp_cnv:
512   0238 3A 6E 27         LD A,(RAM_KEYBOARD)         ; Converte posição da tecla no valor correspondente que representa (função da tecla)
513   023B FE 01            CP 01                       ; Não foi considerada ainda a coluna nesse ponto
514   023D CA 65 02         JP Z,.keyb_disp_num_0
515   0240 FE 02            CP 02
516   0242 CA 6A 02         JP Z,.keyb_disp_num_1
517   0245 FE 04            CP 04
518   0247 CA 6F 02         JP Z,.keyb_disp_num_2
519   024A FE 08            CP 08
520   024C CA 74 02         JP Z,.keyb_disp_num_3
521   024F FE 10            CP 16
522   0251 CA 79 02         JP Z,.keyb_disp_num_4
523   0254 FE 20            CP 32
524   0256 CA 7E 02         JP Z,.keyb_disp_num_5
525   0259 FE 40            CP 64
526   025B CA 83 02         JP Z,.keyb_disp_num_6
527   025E FE 80            CP 128
528   0260 CA 88 02         JP Z,.keyb_disp_num_7
529   0263 18 47            JR .wr_display
530   0265              .keyb_disp_num_0:
531   0265 3E 00            LD A,00H
532   0267 47               LD B,A
533   0268 18 21            JR .keyb_col
534   026A              .keyb_disp_num_1:
535   026A 3E 01            LD A,01H
536   026C 47               LD B,A
537   026D 18 1C            JR .keyb_col
538   026F              .keyb_disp_num_2:
539   026F 3E 02            LD A,02H
540   0271 47               LD B,A
541   0272 18 17            JR .keyb_col
542   0274              .keyb_disp_num_3:
543   0274 3E 03            LD A,03H
544   0276 47               LD B,A
545   0277 18 12            JR .keyb_col
546   0279              .keyb_disp_num_4:
547   0279 3E 04            LD A,04H
548   027B 47               LD B,A
549   027C 18 0D            JR .keyb_col
550   027E              .keyb_disp_num_5:
551   027E 3E 05            LD A,05H
552   0280 47               LD B,A
553   0281 18 08            JR .keyb_col
554   0283              .keyb_disp_num_6:
555   0283 3E 06            LD A,06H
556   0285 47               LD B,A
557   0286 18 03            JR .keyb_col
558   0288              .keyb_disp_num_7:
559   0288 3E 07            LD A,07H
560   028A 47               LD B,A
561   028B              .keyb_col:
562   028B 3A 6F 27         LD A,(RAM_KEYB_COL)         ; Decodifica a coluna e calcula o código correto da tecla (0~7H: coluna 1, 8~FH: coluna 2; 10~17H: coluna 3)
563   028E FE 01            CP 01
564   0290 28 0A            JR Z,.keyb_cnv_plus0
565   0292 FE 02            CP 02
566   0294 28 09            JR Z,.keyb_cnv_plus8
567   0296 FE 04            CP 04
568   0298 28 0A            JR Z,.keyb_cnv_plus16
569   029A 18 10            JR .wr_display
570   029C              .keyb_cnv_plus0:                ; Identificado como tecla da coluna 1 (0~7H)
571   029C 78               LD A,B
572   029D 18 08            JR .keyb_cnv_end
573   029F              .keyb_cnv_plus8:                ; Identificado como tecla da coluna 2 (8~FH)
574   029F 78               LD A,B
575   02A0 C6 08            ADD A,08
576   02A2 18 03            JR .keyb_cnv_end
577   02A4              .keyb_cnv_plus16:               ; Identificado como tecla da coluna 1 (10~17H)
578   02A4 78               LD A,B
579   02A5 C6 10            ADD A,16
580   02A7              .keyb_cnv_end:
581   02A7 CB FF            SET 7,A                     ; Seta o bit 7 do valor convertido para dizer que a tecla foi lida, especialmente no caso do zero (0H)
582   02A9 32 6D 27         LD (RAM_KEYB_CONV),A
583   02AC              .wr_display:
584   02AC 7E               LD A,(HL)
585   02AD D3 01            OUT (DISP),A
586   02AF 06 02            LD B, 2
587   02B1 CD C0 02         CALL sys_delay_ms
588   02B4 23               INC HL
589   02B5 79               LD A,C
590   02B6 87               ADD A,A
591   02B7 FE 40            CP 64
592   02B9 C2 24 02         JP NZ, .keyb_disp_loop      ; Se não chegou na última coluna de atualização do display (64), vai para o próximo loop
593   02BC E1               POP HL
594   02BD C1               POP BC
595   02BE C9               RET
596   02BF 00               DB 00H
597   02C0
598   02C0              ; Delay (operative, ms) for clk = 2 MHz (sys_delay_ms);
599   02C0              ; Input: B = delay time (ms) 0,5% ;
600   02C0              ; Affects registers A, B, F
601   02C0              sys_delay_ms:
602   02C0 F5               PUSH AF
603   02C1              .delay_mult:
604   02C1 78               LD A, B
605   02C2 06 98            LD B, 152                ;Number of loops adjusted to A = delay ms with minimum error
606   02C4              .delay_1ms:
607   02C4 10 FE            DJNZ .delay_1ms
608   02C6 47               LD B, A
609   02C7 10 F8            DJNZ .delay_mult
610   02C9 F1               POP AF
611   02CA C9               RET
612   02CB 00               DB 00H
613   02CC
614   02CC              ; Código dos caracteres para exibição no display em sequencia de endereços para facilitar a conversão numérica
615   02CC              DB_NUMCHAR EQU $
616   02CC C0               DB      0C0H                ; Caractere 0
617   02CD F9               DB      0F9H                ; Caractere 1
618   02CE A4               DB      0A4H                ; Caractere 2
619   02CF B0               DB      0B0H                ; Caractere 3
620   02D0 99               DB      099H                ; Caractere 4
621   02D1 92               DB      092H                ; Caractere 5
622   02D2 82               DB      082H                ; Caractere 6
623   02D3 F8               DB      0F8H                ; Caractere 7
624   02D4 80               DB      080H                ; Caractere 8
625   02D5 90               DB      090H                ; Caractere 9
626   02D6 88               DB      088H                ; Caractere A
627   02D7 83               DB      083H                ; Caractere B
628   02D8 C6               DB      0C6H                ; Caractere C
629   02D9 A1               DB      0A1H                ; Caractere D
630   02DA 86               DB      086H                ; Caractere E
631   02DB 8E               DB      08EH                ; Caractere F
632   02DC FF               DB      0FFH                ; Tecla especial 1
633   02DD FF               DB      0FFH                ; Tecla especial 2
634   02DE FF               DB      0FFH                ; Tecla especial 3
635   02DF FF               DB      0FFH                ; Tecla especial 4
636   02E0 FF               DB      0FFH                ; Tecla especial 5
637   02E1 FF               DB      0FFH                ; Tecla especial 6
638   02E2 FF               DB      0FFH                ; Tecla especial 7
639   02E3 FF               DB      0FFH                ; Tecla especial 8
640   02E4
641   02E4 3E 00            LD A,00H
642   02E6 32 FC 25         LD (VAR_TEST),A
643   02E9 CD AE 00         CALL sys_clean_ram_disp
644   02EC CD 18 02         CALL sys_keyb_disp
645   02EF              loop_test_inc:
646   02EF 3A FC 25         LD A,(VAR_TEST)
647   02F2 3C               INC A
648   02F3 32 FC 25         LD (VAR_TEST),A
649   02F6 21 FC 25         LD HL,VAR_TEST
650   02F9 06 14            LD B,20
651   02FB              loop_test_disp:
652   02FB CD BE 00         CALL sys_disp_data
653   02FE 10 FB            DJNZ loop_test_disp
654   0300 18 ED            JR loop_test_inc
655   0302 76               HALT
# file closed: NEMO-80.asm
